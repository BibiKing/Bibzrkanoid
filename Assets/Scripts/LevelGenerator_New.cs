using System;
using System.Collections.Generic;
using UnityEngine;

public class LevelGeneratorAux : MonoBehaviour
{
    // Aux container with metadata
    public class PatternData
    {
        public string Name { get; }
        public int[,] Data { get; }
        public bool DrawFull { get; }
        public bool SpecialColor { get; }

        public PatternData(string name, int[,] data, bool drawFull, bool specialColor)
        {
            Name = name;
            Data = data;
            DrawFull = drawFull;
            SpecialColor = specialColor;
        }
    }

    public List<int[,]> basicShapes = new List<int[,]> {
        new int[,] {
            {1, 1, 1},
            {1, 1, 1},
            {1, 1, 1}
        }, // quadrado,
        new int[,] {
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1}
        }, // retangulo,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // bloco_largo,
        new int[,] {
            {1, 1},
            {1, 1},
            {1, 1},
            {1, 1},
            {1, 1}
        }, // bloco_alto,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0},
            {1, 1, 1, 1, 1},
            {0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0}
        }, // cruz,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {0, 0, 1, 0, 0}
        }, // losango,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1}
        }, // triangulo,
        new int[,] {
            {1, 0, 0},
            {1, 1, 0},
            {1, 1, 1}
        }, // triangulo_ret_esq,
        new int[,] {
            {0, 0, 1},
            {0, 1, 1},
            {1, 1, 1}
        }, // triangulo_ret_dir,
        new int[,] {
            {0, 0, 1, 0, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 0, 1, 0, 0}
        }, // estrela,
        new int[,] {
            {0, 1, 1, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 1, 1, 0, 0, 0}
        }, // coracao,
        new int[,] {
            {0, 0, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 0, 1, 0}
        }, // space_invader,
        new int[,] {
            {1, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0},
            {1, 0, 1, 0, 0, 0},
            {1, 0, 1, 1, 0, 0},
            {1, 0, 1, 0, 1, 0},
            {1, 0, 1, 0, 1, 1}
        }, // escada_alternada,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // espiral,
        new int[,] {
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // zigzag,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // piramide_oca,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // circulo,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // seta,
        new int[,] {
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // x_nucleo,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // labirinto,
        new int[,] {
            {0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 0, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 0, 1, 1, 0, 0, 0}
        }, // ondas,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // hexagono,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // letra_t,
        new int[,] {
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0}
        }, // circulo_pontilhado,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // escudo,
        new int[,] {
            {1, 1, 0, 0, 0, 1, 1},
            {1, 1, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 1, 1},
            {1, 1, 0, 0, 0, 1, 1}
        }, // ponte,
        new int[,] {
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 0}
        }, // nuvem,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 1, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // diamante_risco,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {0, 0, 1, 0, 0}
        }, // flecha_dupla,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // cogumelo,
        new int[,] {
            {0, 1, 1, 1, 0},
            {1, 1, 0, 1, 1},
            {1, 1, 0, 1, 1},
            {0, 1, 1, 1, 0}
        }, // roda,
        new int[,] {
            {1, 1, 0, 0, 1, 1},
            {1, 1, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 0, 0},
            {0, 0, 1, 1, 0, 0}
        } // puzzle
    };

    public List<PatternData> specialShapes = new List<PatternData> {
        new PatternData("gatinho", new int[,] {
            {3, 3, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0},
            {3, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 3, 3, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, -1, 1, 1, -1, 1, 1, 3, 0, 0, 0},
            {3, 1, -1, 1, 1, -1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, -1, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 1, 1, 3, 1, 1, 3, 3},
            {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3},
            {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3},
            {0, 0, 3, 1, 3, 1, 3, 1, 1, 3, 1, 3},
            {0, 0, 3, 1, 3, 1, 3, 3, 3, 3, 1, 3},
            {0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3}
        }, true, true),
        new PatternData("lua crescente", new int[,] {
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 0},
            {0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 1, 0},
            {3, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 1, 0},
            {0, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0}
        }, true, true),
        new PatternData("foice martelo", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1},
            {0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
        }, true, true),
        new PatternData("pokebola", new int[,] {
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 3, 0},
            {0, 3, 1, 0, 0, 0, 1, 1, 1, 1, 3, 0},
            {3, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 3},
            {3, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 3},
            {3, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 3},
            {3, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 3},
            {0, 3, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0},
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0}
        }, true, true),
        new PatternData("controle nintendo", new int[,] {
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 3, 3, 1, 1, 1, 3, 0},
            {3, 1, 1, 3, 1, 1, 1, 1, -1, 1, 1, 3},
            {3, 1, 3, 3, 3, 1, 1, -1, 0, -1, 1, 3},
            {3, 1, 1, 3, 1, 1, 1, 1, -1, 1, 1, 3},
            {0, 3, 1, 1, 1, 3, 3, 1, 1, 1, 3, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0}
        }, true, true),
        new PatternData("smiley", new int[,] {
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 0},
            {0, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 0},
            {1, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0}
        }, true, true),
        new PatternData("duck", new int[,] {
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 3, 1, -1, 1, 1, 1, 0, 0, 0, 0},
            {3, 3, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1},
            {0, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1},
            {0, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("luffy", new int[,] {
            {0, 0, 2, 2, 2, 2, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 0},
            {2, 2, 2, 2, 2, 2, 2, 2},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 0},
            {0, 1, 3, 1, 1, 3, 0, 0},
            {1, 1, 3, 3, 1, 3, 3, 0},
            {1, 1, 3, 3, 1, 3, 3, 0},
            {1, 0, 3, 3, 1, 3, 1, 1},
            {0, 4, 4, 4, 4, 4, 0, 0},
            {4, 4, 4, 0, 0, 4, 4, 0},
            {1, 1, 0, 0, 0, 0, 1, 1}
        }, true, true),
        new PatternData("arvore natal", new int[,] {
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 2, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0},
            {0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0},
            {1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1},
            {0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0},
            {0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0},
            {0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0},
            {0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0}
        }, true, true),
        new PatternData("caveira", new int[,] {
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {1, -1, -1, 1, -1, -1, 1},
            {1, -1, -1, 1, -1, -1, 1},
            {0, 1, 1, -1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, -1, -1, -1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("clave de sol", new int[,] {
            {0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 1, 1, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {1, 0, 0, 1, 1, 1, 0},
            {1, 0, 1, 0, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 0, 1, 1, 0, 0, 0}
        }, true, true),
        new PatternData("notas musicais", new int[,] {
            {0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0}
        }, true, true),
        new PatternData("coroa", new int[,] {
            {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, -1, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 1, 0, 1, 3, 1, 0, 1, 1, 0},
            {1, 3, 3, 1, 3, 3, 3, 1, 3, 3, 1},
            {1, 3, 3, 1, 3, 3, 3, 1, 3, 3, 1},
            {0, 1, 3, 1, 3, 3, 3, 1, 3, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("coracao", new int[,] {
            {0, 0, 4, 4, 0, 0, 4, 4, 0, 0},
            {0, 4, 1, 1, 4, 4, 1, 1, 4, 0},
            {4, 3, 1, 1, 1, 1, 1, -1, 1, 4},
            {4, 3, 1, 1, 1, 1, 1, 1, 1, 4},
            {4, 3, 1, 1, 1, 1, 1, 1, 1, 4},
            {0, 4, 3, 1, 1, 1, 1, 1, 4, 0},
            {0, 0, 4, 3, 1, 1, 1, 4, 0, 0},
            {0, 0, 0, 4, 3, 1, 4, 0, 0, 0},
            {0, 0, 0, 0, 4, 4, 0, 0, 0, 0}
        }, true, true),
        new PatternData("space invader 1", new int[,] {
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 3, 3, 3, 3, 3, 3, 1, 0, 1},
            {1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1}
        }, true, true),
        new PatternData("space invader 2", new int[,] {
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0}
        }, true, true)
    };

    public List<PatternData> hardPatterns = new List<PatternData> {
        new PatternData("linha superior", new int[,] {
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("linha inferior", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3}
        }, true, false),
        new PatternData("diagonais", new int[,] {
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3}
        }, false, false),
        new PatternData("quadrados cocentricos", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("três linhas na metade superior", new int[,] {
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("forma geometrica", new int[,] {
            {0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0},
            {0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0},
            {0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("linha pontilhada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("círculos", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("linhas centrais", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("xadrez", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0}
        }, false, false)
    };

    public List<PatternData> indestructiblePatterns = new List<PatternData> {
        new PatternData("intercalados lateralmente a cada 4 linhas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0}
        }, true, false),
        new PatternData("pontilhado superior e inferior", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("forma mais elaborada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0},
            {0, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0},
            {0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0}
        }, true, false),
        new PatternData("dois Us superiores", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("caixa em L com apenas 1 abertura", new int[,] {
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("zigzag quase fechado", new int[,] {
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("blocos intercalados nas pontas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}
        }, true, false),
        new PatternData("blocos intercalados no meio", new int[,] {
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("M grande (vazado no meio)", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, -1, 0, 0, 0, 0, -1, -1, 0, 0},
            {0, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, 0}
        }, true, false),
        new PatternData("I serifado grande", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("bandeira  vazada", new int[,] {
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, -1, 0, -1, -1, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("U com U invertido dentro", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, -1, -1, -1, -1, -1, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("colunas laterais", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("7s espelhados com u no meio", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("círculo aberto em cima", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("borda de bandeira vazada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, 0, -1, -1, 0, -1, -1, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("t\u00fanel central", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("escadinha", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("m\u00faltiplas colunas centrais vazadas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false)
    };
}

/*
 // Estruturas de máscara
 private struct Mask { public string name; public bool[,] data; public int rows, cols; }
 private List<Mask> hardMasks;
 private List<Mask> indestructibleMasks;

 // ----------------------------- API pública -----------------------------
 public int[,] GetLevel(int index)
 {
     if (index < 0 || index >= levels.Count) throw new ArgumentOutOfRangeException("Index inválido.");
     return levels[index];
 }

 public List<int[,]> GetAllLevels()
 {
     if (levels == null || levels.Count == 0) GenerateLevels();
     return levels;
 }

 public void ExportToTxt(string filePath)
 {
     using (var sw = new StreamWriter(filePath))
     {
         foreach (var lvl in levels)
         {
             for (int y = 0; y < rowCount; y++)
             {
                 string[] row = new string[colCount];
                 for (int x = 0; x < colCount; x++) row[x] = lvl[y, x].ToString();
                 sw.WriteLine(string.Join(",", row));
             }
             sw.WriteLine("--");
         }
     }
 }

 // -------------------------- Geração: visão geral --------------------------
 private void GenerateLevels()
 {
     levels.Clear();

     for (int levelIndex = 0; levelIndex < totalLevels; levelIndex++)
     {
         // Determinismo de posição opcional: RNG por-nível derivado da seed global
         var levelRng = new System.Random(CombineSeed(effectiveSeed, levelIndex, rowCount, colCount));

         // Curva de dificuldade (0..1)
         float t = (totalLevels <= 1) ? 1f : levelIndex / (float)(totalLevels - 1);

         // Quantitativos determinísticos (não dependem de RNG) — o que garante
         // a consistência de contagens para mesmo grid/totalLevels:
         var targets = ComputeTargets(t);

         // 1) base somente com blocos "destrutíveis": começar com (normais + duros) todos como normais
         int[,] baseGrid;
         bool isSpecial = specialLevelsIndexes != null && specialLevelsIndexes.Contains(levelIndex) && nextSpecialLevel < specialLevels.Count;
         if (isSpecial)
         {
             baseGrid = GenerateCenteredSpecialAsNormals(targets.totalDestructible, levelRng);
         }
         else
         {
             baseGrid = GenerateSymmetricNormals(targets.totalDestructible, levelRng);
             AdjustDestructibleCount(baseGrid, targets.totalDestructible, levelRng);
         }

         // 2) promover parte dos normais para "duros" usando máscaras (D)
         if (targets.hardCount > 0)
         {
             PromoteToHard(baseGrid, targets.hardCount, t, levelRng);
         }

         // 3) aplicar indestrutíveis (-1) por máscaras (I), sem bloquear acesso
         if (targets.indestructibleCount > 0)
         {
             PlaceIndestructibles(baseGrid, targets.indestructibleCount, levelRng);
             //EnsureVerticalPassage(baseGrid, levelRng); // garante um “corredor” vertical
         }

         levels.Add(baseGrid);
     }
 }

 // ------------------- Targets (contagens determinísticas) -------------------
 private (int totalDestructible, int hardCount, int indestructibleCount) ComputeTargets(float t)
 {
     // densidade total “destrutíveis” (normais + duros)
     // começa ~30% e vai até ~75%
     int grid = rowCount * colCount;
     float dens = Mathf.Lerp(0.30f, 0.75f, t);
     int totalDestructible = Mathf.Clamp(Mathf.RoundToInt(grid * dens), 1, grid);

     // fração de duros sobe até ~35%
     float hardFrac = Mathf.SmoothStep(0.0f, 0.35f, t);
     int hardCount = Mathf.Clamp(Mathf.RoundToInt(totalDestructible * hardFrac), 0, totalDestructible);

     // indestrutíveis bem contidos, subindo até ~6% do grid (nunca obrigatório)
     float indFrac = t < 0.5f ? 0f : Mathf.SmoothStep(0f, 0.06f, (t - 0.5f) / 0.5f);
     int indestructibleCount = Mathf.Clamp(Mathf.RoundToInt(grid * indFrac), 0, grid - totalDestructible);

     return (totalDestructible, hardCount, indestructibleCount);
 }

 // ------------------------- Base: apenas normais -------------------------
 private int[,] GenerateSymmetricNormals(int targetDestructible, System.Random rng)
 {
     int[,] lvl = CreateEmptyLevel();
     int placed = 0;

     int leftHalfWidth = colCount / 2;
     // Enquanto precisa preencher, escolha shapes simétricas horizontais
     while (placed < targetDestructible)
     {
         string[] shape = GetRandomShape(rng);
         int sw = shape[0].Length;
         int sh = shape.Length;

         int maxX = Math.Max(0, leftHalfWidth - sw);
         int maxY = Math.Max(0, rowCount - sh);
         int ox = rng.Next(0, maxX + 1);
         int oy = rng.Next(0, maxY + 1);

         // vida = 1 (normal) na base
         InsertShape(lvl, shape, ox, oy, 1);

         int mirrorX = colCount - ox - sw;
         InsertShape(lvl, shape, mirrorX, oy, 1);

         placed = CountBlocksPositive(lvl);
         if (placed > rowCount * colCount * 0.95f) break; // escape seguro
     }

     // Opcional: transformar pequena fatia de normais em vida=2 (feedback visual suave)
     RaiseSomeNormalsToTwo(lvl, rng, fraction: 0.15f);

     return lvl;
 }

 private int[,] GenerateCenteredSpecialAsNormals(int targetDestructible, System.Random rng)
 {
     // Reutiliza seu mecanismo de especiais, mas força vida=1 e complementa com formas leves ao redor
     int[,] lvl = CreateEmptyLevel();

     string shapeKey = specialLevels[nextSpecialLevel++];
     string[] art = specialShapes[shapeKey];
     int w = art[0].Length, h = art.Length;
     int ox = Mathf.Max(0, (colCount - w) / 2);
     int oy = Mathf.Max(0, (rowCount - h) / 2);
     InsertShape(lvl, art, ox, oy, 1);

     // Complementa com mais normais simétricos até a meta
     int placed = CountBlocksPositive(lvl);
     if (placed < targetDestructible)
     {
         // “respinga” shapes pequenas ao redor
         int tries = 0;
         while (placed < targetDestructible && tries++ < 200)
         {
             string[] shape = GetRandomShape(rng, preferSmall: true);
             int sw = shape[0].Length, sh = shape.Length;

             int maxX = Math.Max(0, (colCount / 2) - sw);
             int maxY = Math.Max(0, rowCount - sh);
             int oxL = rng.Next(0, maxX + 1);
             int oyL = rng.Next(0, maxY + 1);

             InsertShape(lvl, shape, oxL, oyL, 1);
             int mirrorX = colCount - oxL - sw;
             InsertShape(lvl, shape, mirrorX, oyL, 1);

             placed = CountBlocksPositive(lvl);
         }
     }
     RaiseSomeNormalsToTwo(lvl, rng, fraction: 0.15f);
     return lvl;
 }

 private void AdjustDestructibleCount(int[,] grid, int target, System.Random rng)
 {
     int cur = CountBlocksPositive(grid);
     if (cur == target) return;

     if (cur < target)
     {
         // preencher células vazias com 1 (normais)
         var empties = new List<(int r, int c)>();
         for (int r = 0; r < rowCount; r++)
             for (int c = 0; c < colCount; c++)
                 if (grid[r, c] == 0) empties.Add((r, c));
         Shuffle(empties, rng);
         for (int i = 0; i < empties.Count && cur < target; i++)
         {
             grid[empties[i].r, empties[i].c] = 1;
             cur++;
         }
     }
     else // cur > target
     {
         // remover alguns normais (1–2) até bater a meta (não remova duros/-1)
         var normals = new List<(int r, int c)>();
         for (int r = 0; r < rowCount; r++)
             for (int c = 0; c < colCount; c++)
                 if (grid[r, c] > 0 && grid[r, c] <= 2) normals.Add((r, c));
         Shuffle(normals, rng);
         for (int i = 0; i < normals.Count && cur > target; i++)
         {
             grid[normals[i].r, normals[i].c] = 0;
             cur--;
         }
     }
 }

 // -------------------------- Promover para "duros" --------------------------
 private void PromoteToHard(int[,] grid, int hardTarget, float t, System.Random rng)
 {
     // Vida dos duros: [3 .. hardMax], onde hardMax sobe linear até maxLives
     int hardMax = Mathf.Max(3, Mathf.RoundToInt(Mathf.Lerp(3, maxLives, t)));
     if (hardMax < 3) hardMax = 3;

     // Seleciona uma ou mais máscaras e aplica sobre posições atualmente >0 (normais)
     var candidates = AllMaskPositions(hardMasks, rng).Where(p => grid[p.r, p.c] > 0).ToList();
     // embaralha determinísticamente
     Shuffle(candidates, rng);

     int promoted = 0;
     foreach (var p in candidates)
     {
         if (promoted >= hardTarget) break;
         if (grid[p.r, p.c] <= 0) continue; // só promove quem é normal

         int life = RandomWeightedHardLife(rng, 3, hardMax);
         grid[p.r, p.c] = life;
         promoted++;
     }
     // Se faltou, “salva” promovendo normais aleatórios
     if (promoted < hardTarget)
     {
         var normals = EnumerateCells(grid).Where(x => grid[x.r, x.c] > 0 && grid[x.r, x.c] <= 2).ToList();
         Shuffle(normals, rng);
         foreach (var p in normals)
         {
             if (promoted >= hardTarget) break;
             grid[p.r, p.c] = RandomWeightedHardLife(rng, 3, hardMax);
             promoted++;
         }
     }
 }

 // ------------------------- Colocar indestrutíveis -------------------------
 private void PlaceIndestructibles(int[,] grid, int target, System.Random rng)
 {
     var candidates = AllMaskPositions(indestructibleMasks, rng)
         .Where(p => grid[p.r, p.c] != -1) // evita duplicar
         .ToList();

     Shuffle(candidates, rng);

     int placed = 0;
     foreach (var p in candidates)
     {
         if (placed >= target) break;
         // Não faz sentido colocar -1 em vazio se você quer manter densidade final alta,
         // mas a especificação aceita colocar -1 onde tiver normal/duro (substituição).
         grid[p.r, p.c] = -1;
         placed++;
     }
 }

 // Garante que exista pelo menos um “túnel” vertical sem -1 do topo ao rodapé
 private void EnsureVerticalPassage(int[,] grid, System.Random rng)
 {
     // Escolhe uma coluna "preferencial" perto do centro
     int c = colCount / 2 + rng.Next(-1, 2); // centro ±1
     c = Mathf.Clamp(c, 0, colCount - 1);

     // Se já há corredor natural, ok
     if (ColumnHasNoIndWall(grid, c)) return;

     // Caso contrário, “escava” a coluna escolhida (remove -1 -> vira vazio “0”)
     for (int r = 0; r < rowCount; r++)
     {
         if (grid[r, c] == -1) grid[r, c] = 0;
     }
 }

 private bool ColumnHasNoIndWall(int[,] grid, int c)
 {
     for (int r = 0; r < rowCount; r++)
         if (grid[r, c] == -1) return false;
     return true;
 }

 // ----------------------------- Utilidades -----------------------------
 private int[,] CreateEmptyLevel() => new int[rowCount, colCount];

 private int CountBlocksPositive(int[,] grid)
 {
     int count = 0;
     for (int r = 0; r < rowCount; r++)
         for (int c = 0; c < colCount; c++)
             if (grid[r, c] > 0) count++;
     return count;
 }

 private void InsertShape(int[,] level, string[] shape, int offsetX, int offsetY, int vida)
 {
     for (int y = 0; y < shape.Length; y++)
         for (int x = 0; x < shape[y].Length; x++)
         {
             if (shape[y][x] != '1') continue;
             int lx = offsetX + x;
             int ly = offsetY + y;
             if (lx >= 0 && lx < colCount && ly >= 0 && ly < rowCount)
             {
                 // só preenche se ainda vazio (evita inflar contagem)
                 if (level[ly, lx] == 0) level[ly, lx] = vida;
             }
         }
 }

 private void RaiseSomeNormalsToTwo(int[,] grid, System.Random rng, float fraction)
 {
     var normals = new List<(int r, int c)>();
     for (int r = 0; r < rowCount; r++)
         for (int c = 0; c < colCount; c++)
             if (grid[r, c] == 1) normals.Add((r, c));

     int toRaise = Mathf.RoundToInt(normals.Count * Mathf.Clamp01(fraction));
     Shuffle(normals, rng);
     for (int i = 0; i < toRaise; i++) grid[normals[i].r, normals[i].c] = 2;
 }

 private string[] GetRandomShape(System.Random rng, bool preferSmall = false)
 {
     // mesma ideia do seu GetRandomShape, com leve viés p/ shapes menores quando preferSmall
     var values = shapes.Values.ToList();
     if (preferSmall) values = values.OrderBy(s => s.Length * s[0].Length).Take(Mathf.Max(5, values.Count / 3)).ToList();
     return values[rng.Next(values.Count)];
 }

 private static int CombineSeed(int seed, int levelIndex, int rows, int cols)
 {
     unchecked
     {
         int h = 17;
         h = h * 31 + seed;
         h = h * 31 + levelIndex;
         h = h * 31 + rows;
         h = h * 31 + cols;
         return h;
     }
 }

 private static void Shuffle<T>(IList<T> list, System.Random rng)
 {
     for (int i = list.Count - 1; i > 0; i--)
     {
         int j = rng.Next(i + 1);
         (list[i], list[j]) = (list[j], list[i]);
     }
 }

 private int RandomWeightedHardLife(System.Random rng, int min, int max)
 {
     // dá mais chance para vidas menores no início, crescendo com t (implícito via max)
     // distribuição triangular simples:
     int a = rng.Next(min, max + 1);
     int b = rng.Next(min, max + 1);
     return Math.Min(a, b); // puxa para baixo
 }

 // ----------------------------- Máscaras -----------------------------
 private List<Mask> ParseMasks(TextAsset txt, char marker)
 {
     var list = new List<Mask>();
     if (txt == null) return list;

     var lines = txt.text.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
     var current = new List<string>();
     string currentName = "pattern";

     void Flush()
     {
         if (current.Count == 0) return;
         // converte CSV para bool[,]
         var grid = ParseCsvBlock(current, marker, out int rr, out int cc);
         list.Add(new Mask { name = currentName, data = grid, rows = rr, cols = cc });
         current.Clear();
     }

     foreach (var raw in lines)
     {
         var line = raw.Trim();
         if (string.IsNullOrEmpty(line)) continue;

         if (line.StartsWith("--"))
         {
             Flush();
             currentName = line.Substring(2).Trim();
         }
         else
         {
             current.Add(line);
         }
     }
     Flush();
     return list;
 }

 private bool[,] ParseCsvBlock(List<string> rows, char marker, out int rCount, out int cCount)
 {
     rCount = rows.Count;
     cCount = rows[0].Split(',').Length;
     var data = new bool[rCount, cCount];

     for (int r = 0; r < rCount; r++)
     {
         var cols = rows[r].Split(',');
         for (int c = 0; c < cCount; c++)
         {
             var token = cols[c].Trim();
             data[r, c] = token.Length > 0 && token[0] == marker;
         }
     }
     return data;
 }

 private IEnumerable<(int r, int c)> AllMaskPositions(List<Mask> masks, System.Random rng)
 {
     // escolhe uma máscara aleatória e um offset válido, ou concatena várias
     if (masks == null || masks.Count == 0) yield break;

     // 1 a 2 máscaras por aplicação para variedade
     int howMany = masks.Count < 2 ? 1 : rng.Next(1, 3);
     var chosen = new List<Mask>();
     for (int i = 0; i < howMany; i++) chosen.Add(masks[rng.Next(masks.Count)]);

     foreach (var m in chosen)
     {
         int maxX = Math.Max(0, colCount - m.cols);
         int maxY = Math.Max(0, rowCount - m.rows);
         int ox = rng.Next(0, maxX + 1);
         int oy = rng.Next(0, maxY + 1);

         for (int r = 0; r < m.rows; r++)
             for (int c = 0; c < m.cols; c++)
             {
                 if (!m.data[r, c]) continue;
                 int gr = oy + r, gc = ox + c;
                 if (gr >= 0 && gr < rowCount && gc >= 0 && gc < colCount)
                     yield return (gr, gc);
             }
     }
 }

 private IEnumerable<(int r, int c)> EnumerateCells(int[,] grid)
 {
     for (int r = 0; r < rowCount; r++)
         for (int c = 0; c < colCount; c++)
             yield return (r, c);
 }

 // --------------------- Seus métodos de especiais (preservados) ---------------------
 private void GenerateSpecialLevels()
 {
     specialLevelsIndexes = new List<int>();
     int numberOfSpecialLevels = random.Next(Math.Min(1, totalLevels - 1), Math.Max(2, totalLevels / 3));

     for (int i = 0; i < numberOfSpecialLevels; i++)
     {
         int idx;
         do { idx = random.Next(0, Math.Max(2, totalLevels - 2)); }
         while (specialLevelsIndexes.Contains(idx));
         specialLevelsIndexes.Add(idx);

         do { idx = random.Next(0, specialShapes.Count()); }
         while (specialLevels.Contains(specialShapes.Keys.ElementAt(idx)));

         specialLevels.Add(specialShapes.Keys.ElementAt(idx));
     }
 }*/
