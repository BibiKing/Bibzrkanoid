using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{

    // Aux container with metadata
    public class PatternData
    {
        public string Name { get; }
        public int[,] Data { get; }
        public bool DrawFull { get; }
        public bool SpecialColor { get; }

        public PatternData(string name, int[,] data, bool drawFull, bool specialColor)
        {
            Name = name;
            Data = data;
            DrawFull = drawFull;
            SpecialColor = specialColor;
        }
    }

    public List<int[,]> basicShapes = new List<int[,]> {
        new int[,] {
            {1, 1, 1},
            {1, 1, 1},
            {1, 1, 1}
        }, // quadrado,
        new int[,] {
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1}
        }, // retangulo,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // bloco_largo,
        new int[,] {
            {1, 1},
            {1, 1},
            {1, 1},
            {1, 1},
            {1, 1}
        }, // bloco_alto,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0},
            {1, 1, 1, 1, 1},
            {0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0}
        }, // cruz,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {0, 0, 1, 0, 0}
        }, // losango,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1}
        }, // triangulo,
        new int[,] {
            {1, 0, 0},
            {1, 1, 0},
            {1, 1, 1}
        }, // triangulo_ret_esq,
        new int[,] {
            {0, 0, 1},
            {0, 1, 1},
            {1, 1, 1}
        }, // triangulo_ret_dir,
        new int[,] {
            {0, 0, 1, 0, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 0, 1, 0, 0}
        }, // estrela,
        new int[,] {
            {0, 1, 1, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 1, 1, 0, 0, 0}
        }, // coracao,
        new int[,] {
            {0, 0, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 0, 1, 0}
        }, // space_invader,
        new int[,] {
            {1, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0},
            {1, 0, 1, 0, 0, 0},
            {1, 0, 1, 1, 0, 0},
            {1, 0, 1, 0, 1, 0},
            {1, 0, 1, 0, 1, 1}
        }, // escada_alternada,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // espiral,
        new int[,] {
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // zigzag,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // piramide_oca,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // circulo,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // seta,
        new int[,] {
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1}
        }, // x_nucleo,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 0, 1},
            {1, 0, 1, 1, 1, 0, 1},
            {1, 0, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 1, 1}
        }, // labirinto,
        new int[,] {
            {0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 0, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 0, 1, 1, 0, 0, 0}
        }, // ondas,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // hexagono,
        new int[,] {
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // letra_t,
        new int[,] {
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 0, 1},
            {0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0}
        }, // circulo_pontilhado,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, // escudo,
        new int[,] {
            {1, 1, 0, 0, 0, 1, 1},
            {1, 1, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 1, 1},
            {1, 1, 0, 0, 0, 1, 1}
        }, // ponte,
        new int[,] {
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 0}
        }, // nuvem,
        new int[,] {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 1, 0, 1, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // diamante_risco,
        new int[,] {
            {0, 0, 1, 0, 0},
            {0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1},
            {0, 1, 1, 1, 0},
            {0, 0, 1, 0, 0}
        }, // flecha_dupla,
        new int[,] {
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0}
        }, // cogumelo,
        new int[,] {
            {0, 1, 1, 1, 0},
            {1, 1, 0, 1, 1},
            {1, 1, 0, 1, 1},
            {0, 1, 1, 1, 0}
        }, // roda,
        new int[,] {
            {1, 1, 0, 0, 1, 1},
            {1, 1, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 0, 0},
            {0, 0, 1, 1, 0, 0}
        } // puzzle
    };

    public List<int[,]> lateMotifShapes = new List<int[,]>
{
    // Diamante vazado
    new int[,] {
        {0,0,1,0,0},
        {0,1,0,1,0},
        {1,0,0,0,1},
        {0,1,0,1,0},
        {0,0,1,0,0},
    },
    // Anel 6x6
    new int[,] {
        {1,1,1,1,1,1},
        {1,0,0,0,0,1},
        {1,0,0,0,0,1},
        {1,0,0,0,0,1},
        {1,0,0,0,0,1},
        {1,1,1,1,1,1},
    },
    // Chevron (seta) 5x4
    new int[,] {
        {1,0,0,0,1},
        {0,1,0,1,0},
        {0,0,1,0,0},
        {0,1,0,1,0},
    },
    // Dupla coluna 7x5 com vão central
    new int[,] {
        {1,0,0,0,1,0,0},
        {1,0,0,0,1,0,0},
        {1,0,0,0,1,0,0},
        {1,0,0,0,1,0,0},
        {1,0,0,0,1,0,0},
    },
    // Constelação em cruz
    new int[,] {
        {0,0,1,0,0},
        {0,0,0,0,0},
        {1,0,0,0,1},
        {0,0,0,0,0},
        {0,0,1,0,0},
    },
    // Arcos opostos
    new int[,] {
        {0,1,1,1,0, 0,1,1,1,0},
        {1,0,0,0,1, 1,0,0,0,1},
        {1,0,0,0,1, 1,0,0,0,1},
        {0,1,1,1,0, 0,1,1,1,0},
    },
};

    public List<PatternData> specialShapes = new List<PatternData> {
        new PatternData("gatinho", new int[,] {
            {3, 3, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0},
            {3, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 3, 3, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0},
            {3, 1, -1, 1, 1, -1, 1, 1, 3, 0, 0, 0},
            {3, 1, -1, 1, 1, -1, 1, 1, 3, 0, 0, 0},
            {3, 1, 1, -1, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 1, 1, 3, 1, 1, 3, 3},
            {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3},
            {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3},
            {0, 0, 3, 1, 3, 1, 3, 1, 1, 3, 1, 3},
            {0, 0, 3, 1, 3, 1, 3, 3, 3, 3, 1, 3},
            {0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3}
        }, true, true),
        new PatternData("lua crescente", new int[,] {
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 0},
            {0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 1, 0},
            {3, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 1, 0},
            {0, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 3, 3, 0, 0},
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0}
        }, true, true),
        new PatternData("foice martelo", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1},
            {0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
        }, true, true),
        new PatternData("pokebola", new int[,] {
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0},
            {0, 0, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 3, 0},
            {0, 3, 1, 0, 0, 0, 1, 1, 1, 1, 3, 0},
            {3, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 3},
            {3, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 3},
            {3, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 3},
            {3, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 3},
            {0, 3, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0},
            {0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0}
        }, true, true),
        new PatternData("controle nintendo", new int[,] {
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 3, 1, 1, 1, 3, 3, 1, 1, 1, 3, 0},
            {3, 1, 1, 3, 1, 1, 1, 1, -1, 1, 1, 3},
            {3, 1, 3, 3, 3, 1, 1, -1, 0, -1, 1, 3},
            {3, 1, 1, 3, 1, 1, 1, 1, -1, 1, 1, 3},
            {0, 3, 1, 1, 1, 3, 3, 1, 1, 1, 3, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0}
        }, true, true),
        new PatternData("smiley", new int[,] {
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 0},
            {0, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 0},
            {1, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0}
        }, true, true),
        new PatternData("duck", new int[,] {
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 3, 1, -1, 1, 1, 1, 0, 0, 0, 0},
            {3, 3, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 3, 3, 3, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1},
            {0, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1},
            {0, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("luffy", new int[,] {
            {0, 0, 2, 2, 2, 2, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 0},
            {2, 2, 2, 2, 2, 2, 2, 2},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 0},
            {0, 1, 3, 1, 1, 3, 0, 0},
            {1, 1, 3, 3, 1, 3, 3, 0},
            {1, 1, 3, 3, 1, 3, 3, 0},
            {1, 0, 3, 3, 1, 3, 1, 1},
            {0, 4, 4, 4, 4, 4, 0, 0},
            {4, 4, 4, 0, 0, 4, 4, 0},
            {1, 1, 0, 0, 0, 0, 1, 1}
        }, true, true),
        new PatternData("arvore natal", new int[,] {
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 2, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0},
            {0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0},
            {1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1},
            {0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0},
            {0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0},
            {0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0},
            {0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0}
        }, true, true),
        new PatternData("caveira", new int[,] {
            {0, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1},
            {1, -1, -1, 1, -1, -1, 1},
            {1, -1, -1, 1, -1, -1, 1},
            {0, 1, 1, -1, 1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0},
            {0, 1, -1, -1, -1, 1, 0},
            {0, 0, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("clave de sol", new int[,] {
            {0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 1, 1, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {1, 0, 0, 1, 1, 1, 0},
            {1, 0, 1, 0, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {1, 0, 0, 0, 1, 0, 1},
            {0, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 1, 0, 0},
            {0, 0, 1, 1, 0, 0, 0}
        }, true, true),
        new PatternData("notas musicais", new int[,] {
            {0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0}
        }, true, true),
        new PatternData("coroa", new int[,] {
            {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, -1, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 1, 0, 1, 3, 1, 0, 1, 1, 0},
            {1, 3, 3, 1, 3, 3, 3, 1, 3, 3, 1},
            {1, 3, 3, 1, 3, 3, 3, 1, 3, 3, 1},
            {0, 1, 3, 1, 3, 3, 3, 1, 3, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0}
        }, true, true),
        new PatternData("coracao", new int[,] {
            {0, 0, 4, 4, 0, 0, 4, 4, 0, 0},
            {0, 4, 1, 1, 4, 4, 1, 1, 4, 0},
            {4, 3, 1, 1, 1, 1, 1, -1, 1, 4},
            {4, 3, 1, 1, 1, 1, 1, 1, 1, 4},
            {4, 3, 1, 1, 1, 1, 1, 1, 1, 4},
            {0, 4, 3, 1, 1, 1, 1, 1, 4, 0},
            {0, 0, 4, 3, 1, 1, 1, 4, 0, 0},
            {0, 0, 0, 4, 3, 1, 4, 0, 0, 0},
            {0, 0, 0, 0, 4, 4, 0, 0, 0, 0}
        }, true, true),
        new PatternData("space invader 1", new int[,] {
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 3, 3, 3, 3, 3, 3, 1, 0, 1},
            {1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1}
        }, true, true),
        new PatternData("space invader 2", new int[,] {
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0}
        }, true, true)
    };

    public List<PatternData> hardPatterns = new List<PatternData> {
        new PatternData("linha superior", new int[,] {
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("linha inferior", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3}
        }, true, false),
        new PatternData("diagonais", new int[,] {
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3}
        }, false, false),
        new PatternData("quadrados cocentricos", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("três linhas na metade superior", new int[,] {
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("forma geometrica", new int[,] {
            {0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0},
            {0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0},
            {0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0},
            {0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0},
            {0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0},
            {0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("linha pontilhada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("círculos", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 0},
            {0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3},
            {3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("linhas centrais", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, false, false),
        new PatternData("xadrez", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0}
        }, false, false)
    };

    public List<PatternData> indestructiblePatterns = new List<PatternData> {
        new PatternData("intercalados lateralmente a cada 4 linhas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0}
        }, true, false),
        new PatternData("pontilhado superior e inferior", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("forma mais elaborada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0},
            {0, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0},
            {0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0}
        }, true, false),
        new PatternData("dois Us superiores", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("caixa em L com apenas 1 abertura", new int[,] {
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("zigzag quase fechado", new int[,] {
            {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("blocos intercalados nas pontas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}
        }, true, false),
        new PatternData("blocos intercalados no meio", new int[,] {
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("M grande (vazado no meio)", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, -1, 0, 0, 0, 0, -1, -1, 0, 0},
            {0, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, 0}
        }, true, false),
        new PatternData("I serifado grande", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("bandeira  vazada", new int[,] {
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, -1, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, -1, 0, -1, -1, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("U com U invertido dentro", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, -1, -1, -1, -1, -1, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("colunas laterais", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("7s espelhados com u no meio", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1},
            {-1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, -1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("círculo aberto em cima", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, -1, -1, -1, -1, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("borda de bandeira vazada", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, -1, -1, -1, 0, -1, -1, 0, -1, -1, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0},
            {0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("túnel central", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {-1, -1, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("escadinha", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false),
        new PatternData("múltiplas colunas centrais vazadas", new int[,] {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }, true, false)
    };

  
    #region Singleton
    private static LevelGenerator _instance;
    public static LevelGenerator Instance => _instance;
    private void Awake()
    {
        if (_instance != null) { Destroy(gameObject); }
        else { _instance = this; }

        // RNG determinístico se seed != 0
        //this.random = seed != 0 ? new System.Random(seed) : new System.Random();

        if (seed == 0)
        {
            // gera uma seed “de execução” realmente variável
            int tick = Environment.TickCount;
            int guid = Guid.NewGuid().GetHashCode();
            int uni = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
            runtimeSeed = unchecked(tick ^ guid ^ uni);

            effectiveSeed = runtimeSeed;
            // opcional: se quiser ver no Inspector qual seed foi usada nesta execução
            seed = effectiveSeed;
        }
        else
        {
            effectiveSeed = seed;
        }

        this.random = new System.Random(effectiveSeed);

        this.levels = new List<int[,]>();

        rowCount = BricksManager.Instance.maxRows;
        colCount = BricksManager.Instance.maxCols;
        maxLives = Math.Max(3, BricksManager.Instance.maxLives);
        totalLevels = BricksManager.Instance.maxLevels;

        exportFileSeed =  rowCount + "x" + colCount + " to " + totalLevels + " - " + seed.ToString();
        exportFileName = exportFilePath + exportFileSeed + exportFileName;
        htmlExportFileName = exportFilePath + exportFileSeed + htmlExportFileName;
        //pngFolder = exportFileSeed + "/";
        //pngExportPrefix = pngFolder + pngExportPrefix;

        GenerateLevels();
    }
    #endregion

    [Header("Parâmetros")]
    public int seed;
    public int effectiveSeed;
    private int runtimeSeed;
    private int totalLevels, maxLives, rowCount, colCount;

    private List<int[,]> levels;
    public System.Random random;

    // ======================= CONFIG / CAMPANHA / EXPORT =======================

    [Header("Exportação")]
    public string exportFilePath;
    private string exportFileSeed;
    private string pngFolder;

    [Header("ExportaçãoTxt")]
    public bool autoExportTxt = false;
    public string exportFileName = "campaign_export.txt"; // salvo em Application.persistentDataPath

    // ==== Exportação HTML (visual) ====
    [Header("Exportação HTML")]
    public bool autoExportHtml = false;
    public string htmlExportFileName = "campaign_export.html"; // salvo em Application.persistentDataPath

    // ==== Exportação PNG (visual) ====
    [Header("Exportação PNG")]
    public bool autoExportPng = false;
    public string pngExportPrefix = "level_";  // cada nível vira "level_1.png", "level_2.png", ...



    // Conjuntos de controle (consistência por campanha)
    private readonly HashSet<string> usedIndestructibleNames = new HashSet<string>();
    private readonly HashSet<string> usedHardPatternNames = new HashSet<string>();
    private readonly HashSet<string> usedSpecialLevelNames = new HashSet<string>();
    // Níveis que devem usar o esquema SpecialColor no colorizer
    private readonly HashSet<int> _specialColorLevels = new HashSet<int>();
    public bool IsLevelSpecialColor(int levelIndex) => _specialColorLevels.Contains(levelIndex);

    // Planejamento determinístico de níveis especiais
    private List<int> plannedSpecialIndexes;
    private List<string> plannedSpecialNames;

    // Dica de simetria por nível (0=None, 1=Horizontal, 2=Vertical, 3=Quad)
    private readonly List<int> _levelSymmetryHints = new List<int>();
    public int GetSymmetryHintForLevel(int levelIndex)
    {
        if (levelIndex < 0 || levelIndex >= _levelSymmetryHints.Count) return 0;
        return _levelSymmetryHints[levelIndex];
    }

    // ========================== ENUM / HELPERS BÁSICOS =========================

    private enum SymmetryMode { None, Horizontal, Vertical, Quad }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int HeightOf(int[,] m) => m.GetLength(0);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int WidthOf(int[,] m) => m.GetLength(1);

    // (adicione só se ainda não existirem)
    private const int EMPTY = 0;
    private const int INDESTRUCTIBLE = -1;

    /// <summary>
    /// Conta quantas unidades de orçamento seriam necessárias para aplicar o padrão em (row0,col0).
    /// - Retorna int.MaxValue se a aplicação é inválida (sai da área, tenta escrever sobre -1 quando não permitido,
    ///   ou quando drawFull==false e a célula-alvo já está ocupada).
    /// - Só conta no orçamento células destrutíveis novas (v > 0) que forem colocar algo onde hoje é EMPTY.
    /// - v == -1 (indestrutível) nunca entra no orçamento.
    /// </summary>
    private static int CountBudgetNeeded(int[,] grid, int[,] pat, int row0, int col0, bool drawFull)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int h = pat.GetLength(0), w = pat.GetLength(1);

        // fora dos limites? inválido
        if (row0 < 0 || col0 < 0 || row0 + h > R || col0 + w > C)
            return int.MaxValue;

        int need = 0;

        for (int r = 0; r < h; r++)
        {
            for (int c = 0; c < w; c++)
            {
                int v = pat[r, c];
                if (v == 0) continue;             // nada a aplicar
                int rr = row0 + r, cc = col0 + c;
                int g = grid[rr, cc];

                if (v == INDESTRUCTIBLE)
                {
                    // -1 não conta orçamento e a validação de poder/ não poder sobrescrever -1
                    // fica no ApplyPattern (aqui só contamos custo destrutível)
                    continue;
                }

                // v > 0 (destrutível)
                if (!drawFull)
                {
                    // aplicação parcial só pode ir em vazio; se já tem algo, inválido
                    if (g != EMPTY) return int.MaxValue;
                    need += 1; // vai ocupar um slot novo
                }
                else
                {
                    // drawFull: podemos sobrescrever destrutíveis (g > 0) sem custo;
                    // só custa quando cria algo onde era vazio; NUNCA podemos sobrescrever -1
                    if (g == INDESTRUCTIBLE) return int.MaxValue;
                    if (g == EMPTY) need += 1;
                    // (g > 0) => substituição não altera orçamento
                }
            }
        }
        return need;
    }

    /// <summary>
    /// Aplica o padrão em (row0,col0).
    /// - Se allowIndestructible==true, aplica -1 normalmente (não mexe no budget).
    /// - Se allowIndestructible==false, NUNCA escreve -1 e NUNCA sobrescreve -1 existente.
    /// - drawFull==false: só preenche EMPTY; drawFull==true: pode sobrescrever destrutíveis (g>0).
    /// - Para cada célula destrutível nova (v>0 em cima de EMPTY), consome 1 do budget (se houver).
    /// </summary>
    private static void ApplyPattern(
        int[,] grid, int[,] pat, int row0, int col0,
        bool drawFull, bool allowIndestructible, ref int budget)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int h = pat.GetLength(0), w = pat.GetLength(1);

        for (int r = 0; r < h; r++)
        {
            for (int c = 0; c < w; c++)
            {
                int v = pat[r, c];
                if (v == 0) continue;

                int rr = row0 + r, cc = col0 + c;
                if ((uint)rr >= (uint)R || (uint)cc >= (uint)C) continue; // segurança

                int g = grid[rr, cc];

                if (v == INDESTRUCTIBLE)
                {
                    if (!allowIndestructible) continue;       // ignoramos -1 quando não permitido
                                                              // nunca sobrescrevemos algo existente com -1 se você quiser ser mais conservador,
                                                              // mas como esse modo é exclusivo de padrões indestrutíveis, pode sobrescrever destrutíveis.
                    grid[rr, cc] = INDESTRUCTIBLE;
                    continue; // não mexe no budget
                }

                // v > 0 (destrutível)
                if (!drawFull)
                {
                    // só coloca em vazio
                    if (g == EMPTY)
                    {
                        if (budget > 0) { grid[rr, cc] = v; budget--; }
                        // else: orçamento já deveria ter sido validado antes; ignoramos por segurança
                    }
                    // se g != EMPTY, não toca
                }
                else
                {
                    // drawFull: não toca -1; pode sobrescrever destrutíveis
                    if (g == INDESTRUCTIBLE) continue;

                    if (g == EMPTY)
                    {
                        if (budget > 0) { grid[rr, cc] = v; budget--; }
                    }
                    else
                    {
                        // g > 0: substituição sem custo
                        grid[rr, cc] = v;
                    }
                }
            }
        }
    }


    private static void Shuffle<T>(IList<T> list, System.Random rng)
    {
        for (int i = list.Count - 1; i > 0; i--)
        {
            int j = rng.Next(i + 1);
            (list[i], list[j]) = (list[j], list[i]);
        }
    }

    private static int CombineSeed(int seed, int levelIndex, int rows, int cols)
    {
        unchecked
        {
            int h = 17;
            h = h * 31 + seed;
            h = h * 31 + levelIndex;
            h = h * 31 + rows;
            h = h * 31 + cols;
            return h;
        }
    }

    // Contagens simples
    private static int CountDestructible(int[,] grid)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1), cnt = 0;
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] > 0) cnt++;
        return cnt;
    }
    private static int CountBlocksPositive(int[,] grid) => CountDestructible(grid);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool HasClearance(int[,] grid, int[,] pat, int r0, int c0, int minGap)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int h = pat.GetLength(0), w = pat.GetLength(1);
        // bounding box com margem
        int r1 = Math.Max(0, r0 - minGap);
        int c1 = Math.Max(0, c0 - minGap);
        int r2 = Math.Min(R - 1, r0 + h - 1 + minGap);
        int c2 = Math.Min(C - 1, c0 + w - 1 + minGap);

        for (int r = r1; r <= r2; r++)
            for (int c = c1; c <= c2; c++)
                if (grid[r, c] != 0) return false; // qualquer ocupação quebra o clearance

        return true;
    }

    private void TryPlaceMotifSymmetric(
        int[,] grid, int[,] pat, int minGap, System.Random rng,
        out bool placed, out int usedR, out int usedC)
    {
        placed = false; usedR = usedC = 0;
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int h = pat.GetLength(0), w = pat.GetLength(1);
        if (h > R || w > C) return;

        // tenta algumas posições aleatórias na metade esquerda/superior (espelhamos depois)
        int tries = 100;
        while (tries-- > 0)
        {
            int r0 = rng.Next(0, Math.Max(1, R - h + 1));
            int c0 = rng.Next(0, Math.Max(1, (C / 2) - w + 1)); // foco na meia esquerda

            if (!HasClearance(grid, pat, r0, c0, minGap)) continue;

            int budget = int.MaxValue; // orçamento não limita motivo base (normais 1)
                                       // coloca original
            TryApplyPatternWithBudget(grid, pat, r0, c0, drawFull: false, allowIndestructible: false, ref budget);

            // espelho horizontal
            int cMirror = (C - w) - c0;
            if (cMirror != c0 && HasClearance(grid, pat, r0, cMirror, minGap))
            {
                TryApplyPatternWithBudget(grid, pat, r0, cMirror, false, false, ref budget);
            }

            // (opcional) espelho vertical em grids mais altos
            if (R >= h * 2)
            {
                int rMirror = (R - h) - r0;
                if (rMirror != r0 && HasClearance(grid, pat, rMirror, c0, minGap))
                    TryApplyPatternWithBudget(grid, pat, rMirror, c0, false, false, ref budget);

                if (rMirror != r0 && cMirror != c0 && HasClearance(grid, pat, rMirror, cMirror, minGap))
                    TryApplyPatternWithBudget(grid, pat, rMirror, cMirror, false, false, ref budget);
            }

            placed = true; usedR = r0; usedC = c0;
            return;
        }
    }

    // ====================== ESPECIAIS — PLANEJAMENTO FIXO ======================

    private void PlanSpecialLevels(System.Random rng)
    {
        plannedSpecialIndexes = new List<int>();
        plannedSpecialNames = new List<string>();
        usedSpecialLevelNames.Clear();

        if (specialShapes == null || specialShapes.Count == 0 || totalLevels <= 2) return;

        // 20%–30% do total (mín. 1, máx. 1/3)
        int minN = Math.Max(1, Mathf.RoundToInt(totalLevels * 0.20f));
        int maxN = Math.Max(minN, Mathf.RoundToInt(totalLevels * 0.30f));
        int howMany = rng.Next(minN, maxN + 1);

        // índices candidatos: evitamos os 2 primeiros para não assustar
        var idxPool = new List<int>();
        for (int i = 2; i < totalLevels; i++) idxPool.Add(i);
        Shuffle(idxPool, rng);
        plannedSpecialIndexes.AddRange(idxPool.GetRange(0, Mathf.Min(howMany, idxPool.Count)));
        plannedSpecialIndexes.Sort();

        // nomes não repetidos
        var namePool = new List<string>(specialShapes.Count);
        for (int i = 0; i < specialShapes.Count; i++) namePool.Add(specialShapes[i].Name);
        Shuffle(namePool, rng);
        for (int i = 0; i < namePool.Count && plannedSpecialNames.Count < plannedSpecialIndexes.Count; i++)
            if (usedSpecialLevelNames.Add(namePool[i]))
                plannedSpecialNames.Add(namePool[i]);
    }

    private bool TryGetPlannedSpecialForIndex(int levelIndex, out string name)
    {
        name = null;
        if (plannedSpecialIndexes == null || plannedSpecialNames == null) return false;
        int pos = plannedSpecialIndexes.IndexOf(levelIndex);
        if (pos < 0 || pos >= plannedSpecialNames.Count) return false;
        name = plannedSpecialNames[pos];
        return true;
    }

    // ===================== ESPECIAIS — REMAPEAMENTO / VIDA =====================

    private int[,] CloneMatrix(int[,] src)
    {
        int h = src.GetLength(0), w = src.GetLength(1);
        var dst = new int[h, w];
        for (int r = 0; r < h; r++)
            for (int c = 0; c < w; c++)
                dst[r, c] = src[r, c];
        return dst;
    }

    // Valor "padrão" de normais em especiais (deixe 1 – a promoção para 2 fica no pós-processo)
    private int GetStandardBrickValueForLevel(float t) => 1;

    // Remapeia: 1->standard; todos valores iguais >=3 viram o mesmo alvo; -1 pode virar valor alto em early-game
    private int[,] RemapSpecialPatternValues(int[,] src, int standardValue, float t, System.Random rng)
    {
        int h = src.GetLength(0), w = src.GetLength(1);
        var dst = new int[h, w];

        var distinctHi = new HashSet<int>();
        bool hasInd = false;
        int maxNonNeg = 0;

        for (int r = 0; r < h; r++)
            for (int c = 0; c < w; c++)
            {
                int v = src[r, c];
                if (v >= 0 && v > maxNonNeg) maxNonNeg = v;
                if (v >= 3) distinctHi.Add(v);
                if (v == -1) hasInd = true;
            }

        var map = new Dictionary<int, int>();
        map[0] = 0;
        map[1] = standardValue;
        map[2] = 2;

        int cap = GetProgressiveHardCap(t); // teto progressivo
        int baseMin = 3, baseMax = cap;

        // candidatos de 3..cap
        var candidates = new List<int>();
        for (int k = baseMin; k <= baseMax; k++) candidates.Add(k);
        // embaralha determinístico
        Shuffle(candidates, rng);

        foreach (var v in distinctHi)
        {
            // pega o primeiro candidato ainda não usado; se acabar, repete o último do range
            int chosen = -1;
            for (int i = 0; i < candidates.Count; i++)
            {
                if (!map.ContainsValue(candidates[i])) { chosen = candidates[i]; break; }
            }
            if (chosen == -1) chosen = baseMax;
            map[v] = Mathf.Clamp(chosen, baseMin, baseMax);
        }

        bool keepInd = (t >= 2f / 3f);
        if (hasInd)
        {
            map[-1] = keepInd ? -1 : Mathf.Max(maxNonNeg, baseMax) + 1;
        }

        for (int r = 0; r < h; r++)
            for (int c = 0; c < w; c++)
            {
                int v = src[r, c];
                dst[r, c] = map.TryGetValue(v, out int to) ? to : v;
            }

        return dst;
    }

    // Pós-processo ESPECIAL: normais 1→2 com teto; duros por GRUPO (consistência de pintura)
    private void ApplyNormalLivesScaling(int[,] grid, float t, System.Random rng)
    {
        // mesma função que você já tem — deixo uma implementação segura aqui caso precise
        int R = grid.GetLength(0), C = grid.GetLength(1);
        var ones = new List<(int r, int c)>();
        var twos = new List<(int r, int c)>();
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
            {
                int v = grid[r, c];
                if (v == 1) ones.Add((r, c));
                else if (v == 2) twos.Add((r, c));
            }

        float targetFrac = (t <= 0.25f) ? 0f : Mathf.Lerp(0f, 0.5f, Mathf.SmoothStep(0f, 1f, (t - 0.25f) / 0.75f));
        int total = ones.Count + twos.Count;
        int targetTwo = Mathf.FloorToInt(total * targetFrac);
        int haveTwo = twos.Count;

        if (t <= 0.25f)
        {
            for (int i = 0; i < twos.Count; i++) grid[twos[i].r, twos[i].c] = 1;
            return;
        }

        if (haveTwo < targetTwo)
        {
            int toPromote = Mathf.Min(targetTwo - haveTwo, ones.Count);
            Shuffle(ones, rng);
            for (int i = 0; i < toPromote; i++) grid[ones[i].r, ones[i].c] = 2;
        }
        else if (haveTwo > targetTwo)
        {
            int toDowngrade = haveTwo - targetTwo;
            Shuffle(twos, rng);
            for (int i = 0; i < toDowngrade; i++) grid[twos[i].r, twos[i].c] = 1;
        }
    }

    private void ApplyHardLivesScalingGrouped(int[,] grid, float t, System.Random rng)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int maxLives = Mathf.Max(3, BricksManager.Instance.maxLives);
        int cap = GetProgressiveHardCap(t);

        if (t <= 0.25f)
        {
            for (int r = 0; r < R; r++)
                for (int c = 0; c < C; c++)
                    if (grid[r, c] >= 3) grid[r, c] = 3;
            return;
        }

        float u = Mathf.Clamp01((t - 0.25f) / 0.75f);
        float mean = Mathf.Lerp(3f, cap, u * u * (3f - 2f * u));
        int minL = Mathf.Clamp(Mathf.FloorToInt(mean - 1f), 3, cap);
        int maxL = Mathf.Clamp(Mathf.CeilToInt(mean + 1f), 3, cap);
        if (minL > maxL) minL = maxL;
        float pMax = Mathf.Clamp01((t - 0.90f) / 0.10f) * 0.30f;

        var distinct = new HashSet<int>();
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] >= 3) distinct.Add(grid[r, c]);

        var map = new Dictionary<int, int>(distinct.Count);
        foreach (var v in distinct)
        {
            double roll = rng.NextDouble();
            int target =
                (roll < pMax) ? maxLives :
                (roll < 0.65) ? Mathf.Clamp(Mathf.RoundToInt(mean), 3, cap) :
                rng.Next(minL, maxL + 1);
            map[v] = Mathf.Clamp(target, 3, cap);
        }

        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] >= 3 && map.TryGetValue(grid[r, c], out int to))
                    grid[r, c] = to;
    }

    private void PostProcessLives_Special(int[,] grid, float t, System.Random rng)
    {
        ApplyNormalLivesScaling(grid, t, rng);
        ApplyHardLivesScalingGrouped(grid, t, rng);
    }

    // ====================== ESPECIAL — GERAÇÃO POR NOME =======================

    private bool TryGenerateSpecialLevel_ByName(int[,] outGrid, string name, float t, System.Random rng)
    {
        var pd = specialShapes.FirstOrDefault(p => p.Name == name);
        if (pd == null) return false;

        // Remapeia conforme regra (1->standard; grupos >=3; -1 opcional)
        int[,] remapped = RemapSpecialPatternValues(pd.Data, GetStandardBrickValueForLevel(t), t, rng);

        // Limpa e centraliza
        for (int r = 0; r < rowCount; r++)
            for (int c = 0; c < colCount; c++)
                outGrid[r, c] = 0;

        int h = remapped.GetLength(0), w = remapped.GetLength(1);
        int oy = Mathf.Max(0, (rowCount - h) / 2);
        int ox = Mathf.Max(0, (colCount - w) / 2);

        for (int r = 0; r < h; r++)
            for (int c = 0; c < w; c++)
            {
                int v = remapped[r, c];
                int gr = oy + r, gc = ox + c;
                if ((uint)gr < (uint)rowCount && (uint)gc < (uint)colCount)
                    outGrid[gr, gc] = v;
            }

        // Pós-processo especial (normais 1→2 com teto; duros por grupo)
        PostProcessLives_Special(outGrid, t, rng);

        // Complementação opcional “sem encostar” (caso fique muito vazio);
        // alvo visual: densidade moderada escalando com t
        int cur = CountDestructible(outGrid);
        int targetVisual = Mathf.RoundToInt(rowCount * colCount * Mathf.Lerp(0.18f, 0.32f, t));
        if (cur < targetVisual)
            ComplementSpecialWithoutTouching(outGrid, targetVisual, rng);

        usedSpecialLevelNames.Add(name);
        return true;
    }

    // ======================== BASE SIMÉTRICA E BLIT ===========================

    private int[,] GenerateSymmetricBaseWithMode(int rows, int cols, int targetDestructible, SymmetryMode mode, System.Random rng)
    {
        int[,] lvl = new int[rows, cols];
        int placed = 0;
        int tries = 0;

        while (placed < targetDestructible && tries++ < 200)
        {
            var pat = GetRandomBasicShape(preferSmall: true, rng: rng);
            int h = HeightOf(pat), w = WidthOf(pat);
            if (h > rows || w > cols) continue;

            int ox = rng.Next(0, Math.Max(1, cols - w + 1));
            int oy = rng.Next(0, Math.Max(1, rows - h + 1));

            BlitWithSymmetrySafe(lvl, pat, ox, oy, mode, 1);
            placed = CountBlocksPositive(lvl);
            if (placed > rows * cols * 0.95f) break;
        }

        // leve promoção só estética; a progressão real fica no pós-processo global
        RaiseSomeNormalsToTwo(lvl, rng, 0.10f);
        return lvl;
    }

    private void BlitWithSymmetrySafe(int[,] grid, int[,] pat, int ox, int oy, SymmetryMode mode, int value)
    {
        void BlitOnce(int x, int y)
        {
            int R = grid.GetLength(0), C = grid.GetLength(1);
            int h = pat.GetLength(0), w = pat.GetLength(1);
            for (int r = 0; r < h; r++)
                for (int c = 0; c < w; c++)
                    if (pat[r, c] > 0)
                    {
                        int gr = y + r, gc = x + c;
                        if ((uint)gr < (uint)R && (uint)gc < (uint)C && grid[gr, gc] == 0)
                            grid[gr, gc] = value;
                    }
        }

        int Rg = grid.GetLength(0), Cg = grid.GetLength(1);
        int h = pat.GetLength(0), w = pat.GetLength(1);

        BlitOnce(ox, oy);
        if (mode == SymmetryMode.Horizontal || mode == SymmetryMode.Quad) BlitOnce(Cg - ox - w, oy);
        if (mode == SymmetryMode.Vertical || mode == SymmetryMode.Quad) BlitOnce(ox, Rg - oy - h);
        if (mode == SymmetryMode.Quad) BlitOnce(Cg - ox - w, Rg - oy - h);
    }

    // Pega uma shape básica da sua lista
    private int[,] GetRandomBasicShape(bool preferSmall, System.Random rng)
    {
        if (basicShapes == null || basicShapes.Count == 0) return new int[1, 1] { { 1 } };
        if (!preferSmall) return basicShapes[rng.Next(basicShapes.Count)];

        // bias para menores
        var pool = new List<int[,]>(basicShapes);
        pool.Sort((a, b) => (HeightOf(a) * WidthOf(a)).CompareTo(HeightOf(b) * WidthOf(b)));
        int take = Mathf.Clamp(pool.Count / 3, 3, pool.Count);
        return pool[rng.Next(take)];
    }

    // Pequena ajuda estética
    private void RaiseSomeNormalsToTwo(int[,] grid, System.Random rng, float fraction)
    {
        var cells = new List<(int r, int c)>();
        int R = grid.GetLength(0), C = grid.GetLength(1);
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] == 1) cells.Add((r, c));
        Shuffle(cells, rng);
        int count = Mathf.RoundToInt(cells.Count * Mathf.Clamp01(fraction));
        for (int i = 0; i < count; i++) grid[cells[i].r, cells[i].c] = 2;
    }

    // ===================== AJUSTE FINO (contagem simétrica) ====================

    private void AdjustDestructibleCountFine(int[,] grid, int target, SymmetryMode sym, System.Random rng)
    {
        int cur = CountDestructible(grid);
        if (cur == target) return;
        if (cur < target) FillSymmetricPairs(grid, target - cur, sym, rng);
        else RemoveSymmetricPairs(grid, cur - target, sym, rng);
    }

    /// <summary>
    /// Ajuste fino de contagem SEM preservar simetria:
    /// - Se faltar bloco: preenche vazios com 1 (normal) aleatoriamente.
    /// - Se sobrar bloco: remove apenas normais (1/2) aleatoriamente.
    /// </summary>
    private void AdjustDestructibleCount(int[,] grid, int target, System.Random rng)
    {
        int cur = CountDestructible(grid);
        if (cur == target) return;

        if (cur < target)
        {
            var empties = new List<(int r, int c)>();
            for (int r = 0; r < rowCount; r++)
                for (int c = 0; c < colCount; c++)
                    if (grid[r, c] == 0) empties.Add((r, c));

            Shuffle(empties, rng);
            for (int i = 0; i < empties.Count && cur < target; i++)
            {
                var (er, ec) = empties[i];
                grid[er, ec] = 1; // normal
                cur++;
            }
        }
        else // cur > target
        {
            var normals = new List<(int r, int c)>();
            for (int r = 0; r < rowCount; r++)
                for (int c = 0; c < colCount; c++)
                    if (grid[r, c] > 0 && grid[r, c] <= 2) normals.Add((r, c));

            Shuffle(normals, rng);
            for (int i = 0; i < normals.Count && cur > target; i++)
            {
                var (nr, nc) = normals[i];
                grid[nr, nc] = 0;
                cur--;
            }
        }
    }


    private void FillSymmetricPairs(int[,] grid, int toAdd, SymmetryMode sym, System.Random rng)
    {
        if (toAdd <= 0) return;
        int R = grid.GetLength(0), C = grid.GetLength(1);
        var empties = new List<(int r, int c)>(R * C);
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] == 0) empties.Add((r, c));
        Shuffle(empties, rng);

        for (int i = 0; i < empties.Count && toAdd > 0; i++)
        {
            var (r, c) = empties[i];
            if (grid[r, c] != 0) continue;
            var pair = GetSymmetricPair(r, c, grid, sym);
            if (pair.HasValue)
            {
                var (r2, c2) = pair.Value;
                if (grid[r2, c2] == 0)
                {
                    grid[r, c] = 1; toAdd--;
                    if (toAdd <= 0) break;
                    grid[r2, c2] = 1; toAdd--;
                }
            }
            else { grid[r, c] = 1; toAdd--; }
        }
    }

    private void RemoveSymmetricPairs(int[,] grid, int toRemove, SymmetryMode sym, System.Random rng)
    {
        if (toRemove <= 0) return;
        int R = grid.GetLength(0), C = grid.GetLength(1);
        var normals = new List<(int r, int c)>(R * C);
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] > 0 && grid[r, c] <= 2) normals.Add((r, c));
        Shuffle(normals, rng);

        for (int i = 0; i < normals.Count && toRemove > 0; i++)
        {
            var (r, c) = normals[i];
            if (!(grid[r, c] > 0 && grid[r, c] <= 2)) continue;
            var pair = GetSymmetricPair(r, c, grid, sym);
            if (pair.HasValue)
            {
                var (r2, c2) = pair.Value;
                if (grid[r2, c2] > 0 && grid[r2, c2] <= 2)
                {
                    grid[r, c] = 0; toRemove--;
                    if (toRemove <= 0) break;
                    grid[r2, c2] = 0; toRemove--;
                }
            }
            else { grid[r, c] = 0; toRemove--; }
        }
    }

    private (int r, int c)? GetSymmetricPair(int r, int c, int[,] grid, SymmetryMode sym)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int r2 = r, c2 = c;
        switch (sym)
        {
            case SymmetryMode.Horizontal: c2 = (C - 1) - c; break;
            case SymmetryMode.Vertical: r2 = (R - 1) - r; break;
            case SymmetryMode.Quad:
                c2 = (C - 1) - c;
                if (c2 == c) r2 = (R - 1) - r;
                break;
            case SymmetryMode.None: return null;
        }
        if (r2 == r && c2 == c) return null;
        return (r2, c2);
    }

    // =================== DUROS — PADRÕES COM CONSISTÊNCIA =====================

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private int GetProgressiveHardCap(float t)
    {
        int maxLives = Mathf.Max(3, BricksManager.Instance.maxLives);
        if (t <= 0.25f) return 3;
        float u = Mathf.Clamp01((t - 0.25f) / 0.75f);
        float s = u * u * (3f - 2f * u);
        return Mathf.Clamp(Mathf.RoundToInt(Mathf.Lerp(3f, maxLives, s)), 3, maxLives);
    }

    private int RandomWeightedHardLife(System.Random rng, int min, int max)
    {
        int a = rng.Next(min, max + 1);
        int b = rng.Next(min, max + 1);
        return Math.Min(a, b); // viés para baixo
    }

    private void ApplyHardPatternsConsistently(int[,] grid, int hardTarget, float t, System.Random rng)
    {
        if (hardTarget <= 0) return;

        int added = 0;

        // Prioriza padrões DrawFull não usados
        var full = hardPatterns.Where(p => p.DrawFull && !usedHardPatternNames.Contains(p.Name)).ToList();
        Shuffle(full, rng);

        foreach (var pd in full)
        {
            var m = pd.Data;
            int h = m.GetLength(0), w = m.GetLength(1);

            // Conta quantos >=3 o padrão aportaria
            int countHardInPattern = 0;
            for (int r = 0; r < h; r++)
                for (int c = 0; c < w; c++)
                    if (m[r, c] >= 3) countHardInPattern++;

            if (countHardInPattern == 0) continue;
            if (added + countHardInPattern > hardTarget) continue;

            // posiciona centralizado (simples e estável)
            int oy = Mathf.Max(0, (rowCount - h) / 2);
            int ox = Mathf.Max(0, (colCount - w) / 2);

            for (int r = 0; r < h; r++)
                for (int c = 0; c < w; c++)
                {
                    int v = m[r, c];
                    if (v >= 3)
                    {
                        int gr = oy + r, gc = ox + c;
                        if ((uint)gr < (uint)rowCount && (uint)gc < (uint)colCount)
                            grid[gr, gc] = v;
                    }
                }

            usedHardPatternNames.Add(pd.Name);
            added += countHardInPattern;
            if (added >= hardTarget) break;
        }

        if (added >= hardTarget) return;

        // Completa promocionalmente sobre normais (1/2)
        int maxLives = Mathf.Max(3, BricksManager.Instance.maxLives);
        float u = Mathf.Clamp01((t - 0.25f) / 0.75f);
        int hardMax = Mathf.RoundToInt(Mathf.Lerp(3f, maxLives, u));

        var candidates = new List<(int r, int c)>();
        for (int r = 0; r < rowCount; r++)
            for (int c = 0; c < colCount; c++)
                if (grid[r, c] > 0 && grid[r, c] <= 2) candidates.Add((r, c));
        Shuffle(candidates, rng);

        foreach (var p in candidates)
        {
            if (added >= hardTarget) break;
            grid[p.r, p.c] = RandomWeightedHardLife(rng, 3, hardMax);
            added++;
        }
    }

    // ============== INDESTRUTÍVEL — PATTERN ÚNICO OU SPRINKLE SEGURO ==============
    private static bool TryApplyPatternWithBudget(
    int[,] grid, int[,] pat, int row0, int col0,
    bool drawFull, bool allowIndestructible, ref int budget)
    {
        if (allowIndestructible)
        {
            // -1 não entra na contagem/“budget” e sempre pode sobrescrever
            int dummy = int.MaxValue;
            ApplyPattern(grid, pat, row0, col0,
                         /*drawFull*/ true,
                         /*allowIndestructible*/ true,
                         ref dummy);
            return true;
        }

        // Para destrutíveis, valida orçamento antes
        int need = CountBudgetNeeded(grid, pat, row0, col0, drawFull);
        if (need > budget) return false;

        ApplyPattern(grid, pat, row0, col0,
                     drawFull,
                     /*allowIndestructible*/ false,
                     ref budget);
        return true;
    }


    private bool TryPlaceOneIndestructiblePattern(int[,] grid, float t, System.Random rng)
    {
        // Só no último terço dos níveis (regra geral); se quiser, afine fora deste método
        // Aqui apenas escolhemos uma pattern ainda não usada.
        var pool = new List<PatternData>(indestructiblePatterns.Count);
        for (int i = 0; i < indestructiblePatterns.Count; i++)
        {
            var p = indestructiblePatterns[i];
            if (!usedIndestructibleNames.Contains(p.Name)) pool.Add(p);
        }
        if (pool.Count == 0) return false;

        var chosen = pool[rng.Next(pool.Count)];
        int[,] m = chosen.Data;
        int h = m.GetLength(0), w = m.GetLength(1);
        if (h > rowCount || w > colCount) return false;

        int attempts = 24, dummy = int.MaxValue;
        for (int k = 0; k < attempts; k++)
        {
            int oy = rng.Next(0, rowCount - h + 1);
            int ox = rng.Next(0, colCount - w + 1);
            if (TryApplyPatternWithBudget(grid, m, oy, ox, drawFull: true, allowIndestructible: true, ref dummy))
            {
                usedIndestructibleNames.Add(chosen.Name);
                return true;
            }
        }
        return false;
    }

    private void SprinkleIndestructiblesSafe(int[,] grid, int count, System.Random rng)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        var candidates = new List<(int r, int c)>(R * C);
        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
                if (grid[r, c] >= 0) candidates.Add((r, c));
        Shuffle(candidates, rng);

        int placed = 0;
        for (int i = 0; i < candidates.Count && placed < count; i++)
        {
            var (rr, cc) = candidates[i];
            grid[rr, cc] = -1;
            placed++;
        }
        EnsureVerticalPassage(grid, rng); // garante passagem
    }

    // Garante coluna sem -1 (você já tinha no código antigo; deixo aqui para ter local)
    private void EnsureVerticalPassage(int[,] grid, System.Random rng)
    {
        int c = colCount / 2 + rng.Next(-1, 2);
        c = Mathf.Clamp(c, 0, colCount - 1);
        for (int r = 0; r < rowCount; r++)
            if (grid[r, c] == -1) { grid[r, c] = 0; }
    }

    // ========================= AJUSTES DE VIDAS (NORMAIS) ======================
    // (se você já tem PostProcessLives(...) no arquivo, mantenha o seu; aqui usamos ele)
    private void ApplyHardLivesScaling(int[,] grid, float t, System.Random rng)
    {
        int R = grid.GetLength(0), C = grid.GetLength(1);
        int maxLives = Mathf.Max(3, BricksManager.Instance.maxLives);
        int cap = GetProgressiveHardCap(t);

        if (t <= 0.25f)
        {
            for (int r = 0; r < R; r++)
                for (int c = 0; c < C; c++)
                    if (grid[r, c] >= 3) grid[r, c] = 3;
            return;
        }

        float u = Mathf.Clamp01((t - 0.25f) / 0.75f);
        float mean = Mathf.Lerp(3f, cap, u * u * (3f - 2f * u));
        int minL = Mathf.Clamp(Mathf.FloorToInt(mean - 1f), 3, cap);
        int maxL = Mathf.Clamp(Mathf.CeilToInt(mean + 1f), 3, cap);
        if (minL > maxL) minL = maxL;
        float pMax = Mathf.Clamp01((t - 0.90f) / 0.10f) * 0.30f; // só no fim

        for (int r = 0; r < R; r++)
            for (int c = 0; c < C; c++)
            {
                int v = grid[r, c];
                if (v >= 3)
                {
                    double roll = rng.NextDouble();
                    int candidate =
                        (roll < pMax) ? maxLives :
                        (roll < 0.65) ? Mathf.Clamp(Mathf.RoundToInt(mean), 3, cap) :
                        rng.Next(minL, maxL + 1);
                    grid[r, c] = Mathf.Clamp(candidate, 3, cap);
                }
            }
    }

    // Aplica ambos (normais + duros por célula) — para níveis normais
    private void PostProcessLives(int[,] grid, float t, System.Random rng)
    {
        ApplyNormalLivesScaling(grid, t, rng);
        ApplyHardLivesScaling(grid, t, rng);
    }

    // ===================== COMPLEMENTO DE ESPECIAL (SEM ENCOSTAR) ==============

    private void ComplementSpecialWithoutTouching(int[,] grid, int targetDestructible, System.Random rng)
    {
        int placed = CountDestructible(grid);
        int R = grid.GetLength(0), C = grid.GetLength(1);

        bool IsFreeAndNotTouching(int rr, int cc)
        {
            if (grid[rr, cc] != 0) return false;
            for (int dr = -1; dr <= 1; dr++)
                for (int dc = -1; dc <= 1; dc++)
                {
                    int r2 = rr + dr, c2 = cc + dc;
                    if ((uint)r2 < (uint)R && (uint)c2 < (uint)C)
                        if (grid[r2, c2] != 0) return false;
                }
            return true;
        }

        int tries = 0;
        while (placed < targetDestructible && tries++ < 300)
        {
            var pat = GetRandomBasicShape(preferSmall: true, rng: rng);
            int h = HeightOf(pat), w = WidthOf(pat);
            if (h > R || w > C) continue;

            int ox = rng.Next(0, Math.Max(1, C - w + 1));
            int oy = rng.Next(0, Math.Max(1, R - h + 1));

            bool ok = true;
            for (int r = 0; r < h && ok; r++)
                for (int c = 0; c < w && ok; c++)
                    if (pat[r, c] > 0) ok = IsFreeAndNotTouching(oy + r, ox + c);

            if (!ok) continue;

            for (int r = 0; r < h; r++)
                for (int c = 0; c < w; c++)
                    if (pat[r, c] > 0 && grid[oy + r, ox + c] == 0)
                    {
                        grid[oy + r, ox + c] = 1;
                        placed++;
                        if (placed >= targetDestructible) return;
                    }
        }
    }

    // ============================== EXPORTAÇÃO ================================

    public void ExportCampaignWithSeed(string filePath)
    {
        using (var sw = new StreamWriter(filePath, false, System.Text.Encoding.UTF8))
        {
            sw.WriteLine($"# Seed: {effectiveSeed}");
            sw.WriteLine($"# Grid: {rowCount}x{colCount}");
            sw.WriteLine($"# Levels: {totalLevels}");
            sw.WriteLine("--");
            foreach (var lvl in levels)
            {
                for (int y = 0; y < rowCount; y++)
                {
                    string[] row = new string[colCount];
                    for (int x = 0; x < colCount; x++) row[x] = lvl[y, x].ToString();
                    sw.WriteLine(string.Join(",", row));
                }
                sw.WriteLine("--");
            }
        }
#if UNITY_EDITOR
        Debug.Log($"Campanha exportada em: {filePath}");
#endif
    }

    private static string HtmlColorForValue(int v)
    {
        // Cores: 
        // - vazio (0) = transparente (mostra grid)
        // - 1 (normal 1 vida) = #4CAF50
        // - 2 (normal 2 vidas) = #2E7D32
        // - 3+ (duros) = escala do âmbar ao vermelho conforme valor
        // - -1 (indestrutível) = #212121 (quase preto)
        if (v == 0) return "transparent";
        if (v == -1) return "#212121";
        if (v == 1) return "#4CAF50";
        if (v == 2) return "#2E7D32";
        if (v >= 3)
        {
            // mapear 3..maxLives para #FFA000..#D32F2F
            int max = Math.Max(3, BricksManager.Instance.maxLives);
            float t = (float)(v - 3) / Math.Max(1, (max - 3));
            // interpolação simples entre âmbar (#FFA000) e vermelho (#D32F2F)
            (int r1, int g1, int b1) = (255, 160, 0);
            (int r2, int g2, int b2) = (211, 47, 47);
            int r = (int)(r1 + (r2 - r1) * t);
            int g = (int)(g1 + (g2 - g1) * t);
            int b = (int)(b1 + (b2 - b1) * t);
            return $"rgb({r},{g},{b})";
        }
        // fallback
        return "#9E9E9E";
    }

    private static string HtmlLabelForValue(int v)
    {
        if (v == 0) return "";
        if (v == -1) return "I";
        return v.ToString();
    }

    public void ExportCampaignToHtml(string filePath)
    {
        try
        {
            var sb = new System.Text.StringBuilder(1 << 18); // ~256KB inicial

            // Cabeçalho + CSS
            sb.AppendLine("<!DOCTYPE html><html lang=\"pt-br\"><head><meta charset=\"utf-8\">");
            sb.AppendLine("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">");
            sb.AppendLine("<title>Campanha - Export</title>");
            sb.AppendLine(@"<style>
            :root { --cell: 18px; --gap: 2px; --bg: #121212; --fg:#e0e0e0; --grid:#2a2a2a; }
            body { background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
            h1, h2, h3 { margin: 0.5rem 0; }
            .meta { opacity:.8; margin-bottom:12px; }
            .levels { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px,1fr)); gap: 16px; }
            .card { background: #1b1b1b; border: 1px solid #2c2c2c; border-radius: 12px; padding: 12px; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
            .grid { display: grid; gap: var(--gap); background: var(--grid); padding: var(--gap); border-radius: 8px; }
            .cell { width: var(--cell); height: var(--cell); display:flex; align-items:center; justify-content:center;
                    font-size: 12px; line-height: 1; border-radius: 3px; color: #111; font-weight: 700; }
            .legend { display:flex; gap:10px; flex-wrap: wrap; margin-top:8px; }
            .chip { display:flex; align-items:center; gap:6px; font-size:12px; padding: 2px 6px; background:#202020; border:1px solid #2c2c2c; border-radius:6px; }
            .box { width:14px; height:14px; border-radius:3px; border:1px solid #0006; }
            .footer { margin-top: 24px; opacity:.7; font-size: 12px; }
        </style>");
            sb.AppendLine("</head><body>");

            // Título e meta
            sb.AppendLine($"<h1>Campanha exportada</h1>");
            sb.AppendLine($"<div class=\"meta\">Seed: <b>{effectiveSeed}</b> • Grid: <b>{rowCount}×{colCount}</b> • Levels: <b>{levels.Count}</b></div>");

            // Legenda
            sb.AppendLine("<div class=\"legend\">");
            sb.AppendLine($"<div class=\"chip\"><span class=\"box\" style=\"background:transparent\"></span> Vazio</div>");
            sb.AppendLine($"<div class=\"chip\"><span class=\"box\" style=\"background:{HtmlColorForValue(1)}\"></span> Normal (1)</div>");
            sb.AppendLine($"<div class=\"chip\"><span class=\"box\" style=\"background:{HtmlColorForValue(2)}\"></span> Normal (2)</div>");
            sb.AppendLine($"<div class=\"chip\"><span class=\"box\" style=\"background:{HtmlColorForValue(3)}\"></span> Duro (3+)</div>");
            sb.AppendLine($"<div class=\"chip\"><span class=\"box\" style=\"background:{HtmlColorForValue(-1)}\"></span> Indestrutível (I)</div>");
            sb.AppendLine("</div>");

            // Níveis
            sb.AppendLine("<div class=\"levels\">");
            for (int li = 0; li < levels.Count; li++)
            {
                var lvl = levels[li];
                sb.AppendLine("<div class=\"card\">");
                sb.AppendLine($"<h3>Nível {li + 1}</h3>");

                // grade
                sb.AppendLine($"<div class=\"grid\" style=\"grid-template-columns: repeat({colCount}, var(--cell));\">");
                for (int r = 0; r < rowCount; r++)
                {
                    for (int c = 0; c < colCount; c++)
                    {
                        int v = lvl[r, c];
                        string bg = HtmlColorForValue(v);
                        string label = HtmlLabelForValue(v);
                        // borda leve para visualizar células vazias
                        string border = (v == 0) ? "border:1px dashed #0006; color:#999;" : "border:1px solid #0006;";
                        // contraste do texto sobre células escuras
                        string txtColor = (v == -1 || v >= 3) ? "color:#e8e8e8;" : "color:#111;";
                        sb.Append($"<div class=\"cell\" style=\"background:{bg}; {border} {txtColor}\">{label}</div>");
                    }
                }
                sb.AppendLine("</div>"); // grid
                sb.AppendLine("</div>"); // card
            }
            sb.AppendLine("</div>"); // levels

            // Rodapé
            sb.AppendLine("<div class=\"footer\">Arquivo gerado pelo LevelGenerator • " +
                          System.DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + " • Seed " + effectiveSeed + "</div>");

            sb.AppendLine("</body></html>");

            System.IO.File.WriteAllText(filePath, sb.ToString(), System.Text.Encoding.UTF8);

#if UNITY_EDITOR
            Debug.Log($"HTML exportado em: {filePath}");
#endif
        }
        catch (System.Exception ex)
        {
#if UNITY_EDITOR
            Debug.LogError($"Falha ao exportar HTML: {ex}");
#endif
        }
    }

    public void ExportCampaignToPngs(string folderPath)
    {
        try
        {
            for (int li = 0; li < levels.Count; li++)
            {
                var grid = levels[li];
                int cellSize = 16;   // px de cada célula
                int gap = 1;         // px de espaçamento entre blocos
                int w = colCount * (cellSize + gap) + gap;
                int h = rowCount * (cellSize + gap) + gap;

                Texture2D tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
                Color bg = new Color(0.07f, 0.07f, 0.07f, 1f); // fundo
                for (int y = 0; y < h; y++)
                    for (int x = 0; x < w; x++)
                        tex.SetPixel(x, y, bg);

                // desenha blocos
                for (int r = 0; r < rowCount; r++)
                {
                    for (int c = 0; c < colCount; c++)
                    {
                        int v = grid[r, c];
                        Color col = ColorForValue(v);

                        int startX = c * (cellSize + gap) + gap;
                        int startY = (rowCount - 1 - r) * (cellSize + gap) + gap; // invertido pra origem em baixo

                        for (int yy = 0; yy < cellSize; yy++)
                            for (int xx = 0; xx < cellSize; xx++)
                                tex.SetPixel(startX + xx, startY + yy, col);
                    }
                }

                tex.Apply();
                byte[] bytes = tex.EncodeToPNG();
                string fileName = $"{pngExportPrefix}{li + 1}.png";
                string path = System.IO.Path.Combine(folderPath, fileName);
                System.IO.File.WriteAllBytes(path, bytes);

#if UNITY_EDITOR
                Debug.Log($"PNG exportado: {path}");
#endif

                UnityEngine.Object.Destroy(tex);
            }
        }
        catch (System.Exception ex)
        {
#if UNITY_EDITOR
            Debug.LogError($"Falha ao exportar PNG: {ex}");
#endif
        }
    }

    /// <summary>Mesma lógica do HtmlColorForValue mas retornando Color.</summary>
    private Color ColorForValue(int v)
    {
        if (v == 0) return new Color(0, 0, 0, 0);     // vazio transparente
        if (v == -1) return Color.black;           // indestrutível
        if (v == 1) return new Color(0.3f, 0.8f, 0.3f); // verde claro
        if (v == 2) return new Color(0.1f, 0.5f, 0.1f); // verde escuro
        if (v >= 3)
        {
            int max = Math.Max(3, BricksManager.Instance.maxLives);
            float t = (float)(v - 3) / Math.Max(1, (max - 3));
            Color amber = new Color(1f, 0.62f, 0f);
            Color red = new Color(0.83f, 0.18f, 0.18f);
            return Color.Lerp(amber, red, t);
        }
        return Color.gray;
    }


    // =========================== GERAÇÃO PRINCIPAL ============================

    private (int totalDestructible, int hardCount, int indestructibleCount) ComputeTargets(float t)
    {
        int grid = rowCount * colCount;

        int startBlocks = Mathf.Clamp(20, 1, grid);
        int endBlocks = Mathf.Clamp(Mathf.RoundToInt(grid * 0.65f), startBlocks, grid);
        int totalDestructible = Mathf.RoundToInt(Mathf.Lerp(startBlocks, endBlocks, t));

        float hardFrac = Mathf.SmoothStep(0.05f, 0.35f, t);
        int hardCount = Mathf.Clamp(Mathf.RoundToInt(totalDestructible * hardFrac), 0, totalDestructible);

        // decidimos -1 fora daqui (integral único ou sprinkle tardio)
        return (totalDestructible, hardCount, 0);
    }

    public List<int[,]> GetAllLevels()
    {
        if (levels == null || levels.Count == 0) GenerateLevels();
        return levels;
    }

    private void GenerateLevels()
    {
        levels.Clear();
        usedIndestructibleNames.Clear();
        usedHardPatternNames.Clear();
        usedSpecialLevelNames.Clear();
        _levelSymmetryHints.Clear();

        // Planejamento determinístico dos especiais
        var planRng = new System.Random(CombineSeed(effectiveSeed, 777, rowCount, colCount));
        PlanSpecialLevels(planRng);

        for (int levelIndex = 0; levelIndex < totalLevels; levelIndex++)
        {
            var levelRng = new System.Random(CombineSeed(effectiveSeed, levelIndex, rowCount, colCount));
            float t = (totalLevels <= 1) ? 1f : levelIndex / (float)(totalLevels - 1);
            var targets = ComputeTargets(t);

            // Simetria progressiva
            SymmetryMode sym =
                (t < 0.30f) ? SymmetryMode.Quad :
                (t < 0.55f) ? SymmetryMode.Horizontal :
                (t < 0.75f) ? SymmetryMode.Vertical :
                              SymmetryMode.None;

            int SymToHint(SymmetryMode m) =>
                (m == SymmetryMode.Quad) ? 3 :
                (m == SymmetryMode.Vertical) ? 2 :
                (m == SymmetryMode.Horizontal) ? 1 : 0;
            _levelSymmetryHints.Add(SymToHint(sym));

            int[,] grid = new int[rowCount, colCount];

            // Especiais planejados (integrais)
            if (TryGetPlannedSpecialForIndex(levelIndex, out string specialName))
            {
                if (TryGenerateSpecialLevel_ByName(grid, specialName, t, levelRng))
                {
                    levels.Add(grid);
                    _specialColorLevels.Add(levelIndex);
                    continue;
                }
            }

            // Nível normal: base simétrica + ajuste fino
            grid = GenerateSymmetricBaseWithMode(rowCount, colCount, targets.totalDestructible, sym, levelRng);

            // Checagem: se estamos no late game, gerar motivos no lugar do normal
            bool isLateGame = t >= 0.70f; // só deixa de lado especiais integrais, que já tratamos acima
            if (isLateGame)
            {
                GenerateLateGameMotifLevel(levelIndex, t, levelRng, ref grid, targets.totalDestructible);

                // Ajuste fino para bater meta de blocos, mas respeitando o desenho dos motivos
                AdjustDestructibleCount(grid, targets.totalDestructible, levelRng);
            }
            else
            {
                // Ajuste fino para bater meta (mantém simetria)
                AdjustDestructibleCountFine(grid, targets.totalDestructible, sym, levelRng);
            }

            // Duros por padrão (consistência) + pós-processo de vidas
            ApplyHardPatternsConsistently(grid, targets.hardCount, t, levelRng);
            PostProcessLives(grid, t, levelRng);

            // Indestrutível integral (1 pattern no fim da campanha) OU sprinkle tardio seguro
            bool lateCampaign = levelIndex >= (int)(totalLevels * 2f / 3f);
            bool placedFullInd = false;
            if (lateCampaign && levelRng.NextDouble() < 0.5) // chance de ter integral
                placedFullInd = TryPlaceOneIndestructiblePattern(grid, t, levelRng);

            if (lateCampaign && !placedFullInd && levelRng.NextDouble() < 0.45)
            {
                int sprinkle = Mathf.RoundToInt(rowCount * colCount * Mathf.Lerp(0.01f, 0.03f, t)); // 1–3%
                SprinkleIndestructiblesSafe(grid, sprinkle, levelRng);
            }

            if(!placedFullInd) 
            // failsafe de jogabilidade            
                EnsureVerticalPassage(grid, levelRng);

            levels.Add(grid);        }



        if (autoExportTxt)
        {
            string path = System.IO.Path.Combine(Application.persistentDataPath, exportFileName);
            ExportCampaignWithSeed(path);
        }

        if (autoExportHtml)
        {
            string pathHtml = System.IO.Path.Combine(Application.persistentDataPath, htmlExportFileName);
            ExportCampaignToHtml(pathHtml);
        }

        if (autoExportPng)
        {
            ExportCampaignToPngs(Application.persistentDataPath);
        }
    }

    // Geração endgame focada em motivos + simetria + respiro
    private void GenerateLateGameMotifLevel(int levelIndex, float t, System.Random rng, ref int[,] grid, int targetDestructible)
    {
        // 1) Defina um gap mínimo em função do grid (mais respiro no fim)
        int minGap = Math.Max(1, Math.Min(rowCount, colCount) / 8);

        // 2) Coloque 2–4 motivos grandes simétricos
        int motifs = Mathf.Clamp(Mathf.RoundToInt(Mathf.Lerp(2f, 4f, t)), 2, 4);
        for (int i = 0; i < motifs; i++)
        {
            var pat = lateMotifShapes[rng.Next(lateMotifShapes.Count)];
            TryPlaceMotifSymmetric(grid, pat, minGap, rng, out bool placed, out _, out _);
        }

        // 3) Complete com shapes básicas pequenas, respeitando clearance
        // Meta: ~80–90% do target, para manter áreas vazias visíveis
        int desired = Mathf.RoundToInt(targetDestructible * Mathf.Lerp(0.75f, 0.9f, t));
        int budget = Math.Max(0, desired - CountBlocksPositive(grid));
        int safety = 600;

        while (budget > 0 && safety-- > 0)
        {
            var pat = basicShapes[rng.Next(basicShapes.Count)];
            // descarte shapes grandes demais nesta fase de “complemento”
            if (pat.GetLength(0) * pat.GetLength(1) > (rowCount * colCount) / 10) continue;

            int h = pat.GetLength(0), w = pat.GetLength(1);
            int r0 = rng.Next(0, Math.Max(1, rowCount - h + 1));
            int c0 = rng.Next(0, Math.Max(1, colCount - w + 1));

            if (!HasClearance(grid, pat, r0, c0, minGap)) continue;

            int need = CountBudgetNeeded(grid, pat, r0, c0, drawFull: false);
            if (need == int.MaxValue || need > budget) continue;

            TryApplyPatternWithBudget(grid, pat, r0, c0, drawFull: false, allowIndestructible: false, ref budget);
        }

        // 4) Opcional: um último toque de simetria com shape médio se ainda houver folga
        if (budget > 0)
        {
            var mid = basicShapes.OrderBy(s => s.GetLength(0) * s.GetLength(1)).Skip(basicShapes.Count / 3).FirstOrDefault();
            if (mid != null)
            {
                TryPlaceMotifSymmetric(grid, mid, minGap, rng, out bool placed, out _, out _);
            }
        }
    }

}
