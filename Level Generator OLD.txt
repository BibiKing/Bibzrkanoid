using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{
    #region Singleton

    private static LevelGenerator _instance;

    public static LevelGenerator Instance => _instance;

    private void Awake()
    {
        if (_instance != null)
        {
            Destroy(gameObject);
        }
        else
        {
            _instance = this;
        }

        this.random = seed != 0 ? new System.Random(seed) : new System.Random();
        this.levels = new List<int[,]>();
        this.specialLevels = new List<string>();

        rowCount = BricksManager.Instance.maxRows;
        colCount = BricksManager.Instance.maxCols;
        maxLives = BricksManager.Instance.sprites.Count();
        totalLevels = BricksManager.Instance.maxLevels;

        GenerateSpecialLevels();
        nextSpecialLevel = 0;
        GenerateLevels();
    }

    #endregion

    private int totalLevels;
    private int maxLives;
    public int seed;

    private int rowCount;
    private int colCount;

    private List<int[,]> levels;
    private List<string> specialLevels;
    private List<int> specialLevelsIndexes;
    private int nextSpecialLevel;
    public System.Random random;

    private void Start()
    {
        
    }

    // Formas pré-definidas
    private Dictionary<string, string[]> shapes = new Dictionary<string, string[]>
    {
        { "quadrado", new[] { "111", "111", "111" } },
        { "retangulo", new[] { "11111", "11111", "11111" } },
        { "bloco_largo", new[] { "1111111", "1111111" } },
        { "bloco_alto", new[] { "11", "11", "11", "11", "11" } },
        { "cruz", new[] { "00100", "11111", "00100" } },
        { "losango", new[] { "00100", "01110", "11111", "01110", "00100" } },
        { "triangulo", new[] { "00100", "01110", "11111" } },
        { "triangulo_ret_esq", new[] { "1", "11", "111" } },
        { "triangulo_ret_dir", new[] { "001", "011", "111" } },
        { "estrela", new[] { "00100", "11111", "01110", "11111", "00100" } },
        { "coracao", new[] {
            "01100110", "11111111", "11111111",
            "01111110", "00111100", "00011000"
        }},
        { "space_invader", new[] {
            "00111100","01111110","11011011",
            "11111111","10111101","00100100","01000010"
        }},
        { "escada_alternada", new[] { "100000", "110000", "101000", "101100", "101010", "101011" } },
        { "espiral", new[] { "1111111", "0000001", "1111101", "1000101", "1011101", "1010001", "1111111" } },
        { "zigzag", new[] { "1000001", "0100010", "0010100", "0001000", "0010100", "0100010", "1000001" } },
        { "piramide_oca", new[] { "0001000", "0011100", "0100010", "1000001" } },
        { "circulo", new[] { "0011100", "0100010", "1000001", "1000001", "0100010", "0011100" } },
        { "seta", new[] { "0001000", "0001000", "1111111", "0001000", "0001000" } },
        { "x_nucleo", new[] { "1000001", "0100010", "0010100", "0001000", "0010100", "0100010", "1000001" } },
        { "labirinto", new[] { "1111111", "1000001", "1011101", "1010101", "1011101", "1000001", "1111111" } },
        { "ondas", new[] { "0000000", "0011000", "0100100", "1000010", "0100100", "0011000" } },
        { "hexagono", new[] { "0011100", "0100010", "1000001", "0100010", "0011100" } },
        { "letra_t", new[] { "1111111", "0001000", "0001000", "0001000" } },
        { "circulo_pontilhado", new[] { "0010100", "0100010", "1000001", "0100010", "0010100" } },
        { "escudo", new[] { "0011100", "0111110", "1111111", "1111111", "0111110", "0011100" } },
        { "ponte", new[] { "1100011", "1100011", "0000000", "1100011", "1100011" } },
        { "nuvem", new[] { "0111110", "1111111", "1111111", "0111110" } },
        { "diamante_risco", new[] { "0001000", "0010100", "0101010", "0010100", "0001000" } },
        { "flecha_dupla", new[] { "00100", "01110", "11111", "01110", "00100" } },
        { "cogumelo", new[] { "0011100", "0111110", "1111111", "0001000", "0001000" } },
        { "roda", new[] { "01110", "11011", "11011", "01110" } },
        { "puzzle", new[] { "110011", "110011", "000000", "001100", "001100" } }
    };

    private Dictionary<string, string[]> specialShapes = new Dictionary<string, string[]>
{
    { "diamante_escalonado", new[] {
        "010000000000",
        "000000000000",
        "011000000000",
        "011000000000",
        "000100000000",
        "011010000000",
        "000202000000",
        "022020000000",
        "000202200000",
        "000202200000",
        "033030030000",
        "033333333000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000"
    }},
    { "lua_crescente", new[] {
        "000011100000",
        "001111110000",
        "001111111000",
        "001111111000",
        "011111100000",
        "111111000000",
        "111111000000",
        "111110000000",
        "111100000000",
        "111100000000",
        "111110000000",
        "011111000000",
        "011111000000",
        "001111100000",
        "001111110000",
        "001111110000",
        "000111111000",
        "000011110000"
    }},
    { "foice_martelo", new[] {
        "000001100000",
        "000000110000",
        "000000111000",
        "000000111000",
        "000000011100",
        "111000001100",
        "011100000110",
        "001110000000",
        "001111000000",
        "001111000000",
        "000111000000",
        "000011100000",
        "000001110000",
        "000000111000",
        "000000111100",
        "000000111100",
        "000000011100",
        "000000001110"
    }},
    { "smiley", new[] {
        "000111111000",
        "001000000100",
        "000000000000",
        "000000000000",
        "010000000010",
        "100100010001",
        "100000000001",
        "100000000001",
        "101000000101",
        "101000000101",
        "100111111001",
        "010000000010",
        "000000000000",
        "001000000100",
        "000111111000",
        "000111111000",
        "000000000000",
        "000000000000"
    }},
    { "nave_espacial", new[] {
        "000000100000",
        "000000110000",
        "000001111000",
        "000001111000",
        "000011111100",
        "000111111100",
        "001111111110",
        "001111111111",
        "011111111111",
        "011111111111",
        "111111111111",
        "011111111110",
        "001111111100",
        "001111111100",
        "000111111000",
        "000111111000",
        "000011110000",
        "000001100000"
    }},
    { "arvore_natal", new[] {
        "000001000000",
        "000001000000",
        "000011000000",
        "000011000000",
        "000011000000",
        "000111100000",
        "000111100000",
        "001111110000",
        "001111110000",
        "001111110000",
        "001111111000",
        "001111111000",
        "011111111100",
        "011111111100",
        "111111111100",
        "111111111100",
        "000011000000",
        "000011000000"
    }},
    { "caveira", new[] {
        "001111111100",
        "001000000100",
        "010000000010",
        "010000000010",
        "010000000010",
        "110111110011",
        "111100101111",
        "110000000011",
        "110000000011",
        "110000000011",
        "110111110011",
        "010011100110",
        "010000000110",
        "001000001100",
        "001111111100",
        "001111111100",
        "000000000000",
        "000000000000"
    }},
    { "notas_musicais", new[] {
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000110011000",
        "000110111100",
        "000110100000",
        "000111000000",
        "000111000000",
        "000111000000",
        "000110000000",
        "000110000000",
        "000110000000",
        "000000000000",
        "000000000000",
        "000000000000",
        "000000000000"
    }},
    { "coroa", new[] {
        "001111111100",
        "010000000010",
        "100000000001",
        "100000000001",
        "101011101001",
        "101011101001",
        "101011101001",
        "101011101001",
        "101011101001",
        "101011101001",
        "101011101001",
        "100000000001",
        "100000000001",
        "100000000001",
        "011111111110",
        "011111111110",
        "000000000000",
        "000000000000"
    }},
    { "dragao", new[] {
        "000000011100",
        "000000100010",
        "000011000010",
        "000011000010",
        "001100000010",
        "000000000000",
        "010000000100",
        "100000011000",
        "100001100000",
        "100001100000",
        "110010000000",
        "010100000000",
        "001000000000",
        "001111100000",
        "000000110000",
        "000000110000",
        "000000011000",
        "000000001100"
    }},
    { "coracao", new[] {
        "011100001110",
        "011100001110",
        "111111111111",
        "111111111111",
        "111111111111",
        "111111111111",
        "111111111111",
        "111111111111",
        "111111111111",
        "011111111110",
        "011111111110",
        "011111111110",
        "000111111000",
        "000111111000",
        "000111111000",
        "000111111000",
        "000011110000",
        "000011110000"
    }},
    { "space_invader", new[] {
        "000111111000",
        "000111111000",
        "011111111110",
        "011111111110",
        "011111111110",
        "111011110111",
        "111011110111",
        "111011110111",
        "111111111111",
        "111111111111",
        "100111111001",
        "100111111001",
        "100111111001",
        "000100001000",
        "000100001000",
        "000100001000",
        "011000000110",
        "011000000110"
    }}
};

    /// <summary>
    /// Retorna a matriz de um level pelo índice.
    /// </summary>
    public int[,] GetLevel(int index)
    {
        if (index < 0 || index >= levels.Count)
            throw new ArgumentOutOfRangeException("Index inválido.");
        return levels[index];
    }

    public List<int[,]> GetAllLevels()
    {
        if(levels == null)
        {
            GenerateLevels();
        }
        return levels;
    }

    /// <summary>
    /// Exporta todos os níveis para um arquivo TXT.
    /// </summary>
    public void ExportToTxt(string filePath)
    {
        using (StreamWriter sw = new StreamWriter(filePath))
        {
            foreach (var lvl in levels)
            {
                for (int y = 0; y < rowCount; y++)
                {
                    string[] row = new string[colCount];
                    for (int x = 0; x < colCount; x++)
                        row[x] = lvl[y, x].ToString();
                    sw.WriteLine(string.Join(",", row));
                }
                sw.WriteLine("--");
            }
        }
    }

    /// <summary>
    /// Gera todos os níveis com progressão de dificuldade e densidade.
    /// </summary>
    
    private void GenerateSpecialLevels()
    {

        specialLevelsIndexes = new List<int>();
        int numberOfSpecialLevels;
        numberOfSpecialLevels = random.Next(Math.Min(1, totalLevels-1),totalLevels/3);


        for (int i = 0; i < numberOfSpecialLevels; i++)
        {
            int index;

            do
            {
                index = random.Next(0, Math.Max(2, totalLevels - 2));
            } while(specialLevelsIndexes.Contains(index));
            specialLevelsIndexes.Add(index);
            

            do
            {
                index = random.Next(0, specialShapes.Count());
            } while(specialLevels.Contains(specialShapes.Keys.ElementAt(index)));

            specialLevels.Add(specialShapes.Keys.ElementAt(index));
        }

    }

    private int[,] GenerateNextSpecialLevel(int vidaMin, int vidaMax)
    {
        int[,] specialLevel = CreateEmptyLevel();
        string shape = specialLevels[nextSpecialLevel];
        int offsetX;
        int width = specialShapes[shape][0].Length;
        int offsetY;
        int height = specialShapes[shape].Length;
        int vida;

        offsetX = (colCount - width)/2;
        offsetY = (rowCount - height)/2;
        vida = random.Next(vidaMin, vidaMax);


        InsertShape(specialLevel, specialShapes[shape], offsetX, offsetY, vida);
        nextSpecialLevel++;

        return specialLevel;
    }

    private void GenerateLevels()
    {
        // níveis progressivos
        for (int i = 0; i < totalLevels; i++)
        {
            // Cálculo para vida mínima: linear de 1 no nível 1 até 50% do máximo no último nível
            double vidaMinimaDouble = 1 + (i - 1) * ((maxLives * 0.5) - 1) / (totalLevels - 1);
            int vidaMin = (int)Math.Round(vidaMinimaDouble);

            // Cálculo para vida máxima: linear de 1 no nível 1 até quantidadeMaximaDeVidas no último nível
            double vidaMaximaDouble = 1 + (i - 1) * (maxLives - 1) / (totalLevels - 1);
            int vidaMax = (int)Math.Round(vidaMaximaDouble);

            // Garantir que os valores não sejam menores que 1
            vidaMin = Math.Max(1, vidaMin);
            vidaMax = Math.Max(1, vidaMax);

            // Garantir que a vida mínima não ultrapasse a vida máxima
            vidaMin = Math.Min(vidaMin, vidaMax);
            //Garantir que no últmo nível a vida máxima seja o máximo
            if ( i == totalLevels - 1)
            {
                vidaMax = maxLives;
            }



            int targetBlocks = 20 + (int)((i / (float)(totalLevels - 3)) * 150);

            int[,] level;
            do
            {
                if (specialLevelsIndexes.Contains(i) && nextSpecialLevel < specialLevelsIndexes.Count)
                {
                    level = GenerateNextSpecialLevel(vidaMin, vidaMax);
                }
                else
                {
                    level = GenerateSymmetricLevel(vidaMin, vidaMax, targetBlocks);
                }
            }
            while (LevelExists(level));

            ApplyLifePattern(level, vidaMin, vidaMax);

            levels.Add(level);
        }
    }

    /// <summary>
    /// Aplica um padrão de substituição aos blocos não vazios de um nível.
    /// </summary>
    private void ApplyLifePattern(int[,] level, int vidaMin, int vidaMax) 
    {
        if (level == null || level.Length == 0 || vidaMin >= vidaMax)
            return;

        int rows = level.GetLength(0);
        int cols = level.GetLength(1);

        // Garante valores válidos
        vidaMin = Mathf.Max(1, vidaMin);
        vidaMax = Mathf.Max(1, vidaMax);

        // Pré-calcula todos os valores necessários
        int pattern = random.Next(9);
        int[] patternValues = new int[Mathf.Max(rows, cols)];
        int[] chessValues = { random.Next(vidaMin, vidaMax + 1),
                         random.Next(vidaMin, vidaMax + 1) };

        // Evita divisão por zero
        int centerX = cols / 2;
        int centerY = rows / 2;
        float maxDist = Mathf.Max(1, centerX + centerY);
        float maxRadius = Mathf.Max(1, Mathf.Sqrt(centerX * centerX + centerY * centerY));

        // Limite de tentativas para o padrão xadrez
        const int maxAttempts = 100;

        for (int y = 0; y < rows; y++)
        {
            for (int x = 0; x < cols; x++)
            {
                if (level[y, x] > 0)
                {
                    int newValue = level[y, x];

                    switch (pattern)
                    {
                        case 0: // random
                            newValue = random.Next(vidaMin, vidaMax + 1);
                            break;

                        case 1: // diagonal
                            if (x == y || x + y == cols - 1)
                                newValue = random.Next(vidaMin, vidaMax + 1);
                            break;

                        case 2: // faixas_horizontais
                            if (x == 0) patternValues[y] = random.Next(vidaMin, vidaMax + 1);
                            newValue = patternValues[y];
                            break;

                        case 3: // faixas_verticais
                            if (y == 0) patternValues[x] = random.Next(vidaMin, vidaMax + 1);
                            newValue = patternValues[x];
                            break;

                        case 4: // xadrez_faixas
                            int attempts = 0;
                            do
                            {
                                newValue = random.Next(vidaMin, vidaMax + 1);
                                attempts++;
                            } while (attempts < maxAttempts &&
                                    ((x > 0 && level[y, x - 1] == newValue) ||
                                     (y > 0 && level[y - 1, x] == newValue)));

                            if (attempts >= maxAttempts)
                                newValue = (x + y) % 2 == 0 ? vidaMin : vidaMax;
                            break;

                        case 5: // xadrez
                            newValue = chessValues[(x + y) % 2];
                            break;

                        case 6: // gradiente
                            float progressG = (x + y) / maxDist;
                            newValue = Mathf.Clamp((int)Mathf.Round(vidaMin + (vidaMax - vidaMin) * progressG), vidaMin, vidaMax);
                            break;

                        case 7: // espiral
                            float dist = Mathf.Abs(x - centerX) + Mathf.Abs(y - centerY);
                            newValue = Mathf.Clamp((int)Mathf.Round(vidaMin + (vidaMax - vidaMin) * (dist / maxDist)), vidaMin, vidaMax);
                            break;

                        case 8: // circular
                            float dx = x - centerX;
                            float dy = y - centerY;
                            float radius = Mathf.Sqrt(dx * dx + dy * dy);
                            newValue = Mathf.Clamp((int)Mathf.Round(vidaMin + (vidaMax - vidaMin) * (radius / maxRadius)), vidaMin, vidaMax);
                            break;
                    }

                    level[y, x] = newValue;
                }
            }
        }
    }

    /// <summary>
    /// Gera um nível simétrico horizontalmente com densidade e vida especificadas.
    /// </summary>
    private int[,] GenerateSymmetricLevel(int vidaMin, int vidaMax, int targetBlocks)
    {
        int[,] lvl = CreateEmptyLevel();
        int totalBlocks = 0;

        // metade esquerda (arredondando para baixo)
        int leftHalfWidth = colCount / 2;

        while (totalBlocks < targetBlocks)
        {
            string[] shape = GetRandomShape();
            int shapeWidth = shape[0].Length;
            int shapeHeight = shape.Length;

            // faixa válida na metade esquerda
            int maxOffsetX = Math.Max(0, leftHalfWidth - shapeWidth);
            int maxOffsetY = Math.Max(0, rowCount - shapeHeight);

            int offsetX = random.Next(0, maxOffsetX + 1);
            int offsetY = random.Next(0, maxOffsetY + 1);

            int vida = GetRandomVida(vidaMin, vidaMax);
            InsertShape(lvl, shape, offsetX, offsetY, vida);

            int espelho = colCount - offsetX - shapeWidth;
            InsertShape(lvl, shape, espelho, offsetY, vida);

            totalBlocks = CountBlocks(lvl);

            // (opcional) escape defensivo caso targetBlocks seja irreal para o grid:
            if (totalBlocks > (rowCount * colCount * 0.95))
            break;
        }

        return lvl;
    }

    private string[] GetRandomShape()
    {
        List<string[]> values = new List<string[]>(shapes.Values);
        return values[random.Next(values.Count)];
    }

    private int[,] CreateEmptyLevel()
    {
        return new int[rowCount, colCount];
    }

    private void InsertShape(int[,] level, string[] shape, int offsetX, int offsetY, int vida)
    {
        for (int y = 0; y < shape.Length; y++)
        {
            for (int x = 0; x < shape[y].Length; x++)
            {
                if (shape[y][x] == '1')
                {
                    int lx = offsetX + x;
                    int ly = offsetY + y;
                    if (lx >= 0 && lx < colCount && ly >= 0 && ly < rowCount)
                    {
                        level[ly, lx] = vida;
                    }
                }
            }
        }
    }

    private int CountBlocks(int[,] level)
    {
        int count = 0;
        for (int y = 0; y < rowCount; y++)
            for (int x = 0; x < colCount; x++)
                if (level[y, x] > 0) count++;
        return count;
    }

    private int GetRandomVida(int min, int max)
    {
        List<int> pool = new List<int>();
        for (int v = min; v <= max; v++)
        {
            int weight = (v < max) ? 3 : 1;
            for (int k = 0; k < weight; k++)
                pool.Add(v);
        }
        return pool[random.Next(pool.Count)];
    }

    private bool LevelExists(int[,] candidate)
    {
        foreach (var lvl in levels)
        {
            bool same = true;
            for (int y = 0; y < rowCount && same; y++)
                for (int x = 0; x < colCount && same; x++)
                    if (lvl[y, x] != candidate[y, x])
                        same = false;
            if (same) return true;
        }
        return false;
    }
}
